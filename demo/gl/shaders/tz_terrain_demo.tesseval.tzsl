shader(type = tesseval);

import <math>
import <noise>

input(id = 0) vec3 position[];
input(id = 1) mat4 mvp[];
input(id = 5) vec3 camera_position[];
output(id = 0) float vertex_height;

vec3 interpolate3(vec3 v0, vec3 v1, vec3 v2)
{
	return vec3(in::tess_coord.x) * v0 + vec3(in::tess_coord.y) * v1 + vec3(in::tess_coord.z) * v2;
}

mat4 interpolate4m(mat4 m0, mat4 m1, mat4 m2)
{
	return in::tess_coord.x * m0 + in::tess_coord.y * m1 + in::tess_coord.z * m2;
}

void main()
{
	vec3 cam_pos = interpolate3(camera_position[0], camera_position[1], camera_position[2]);
	// if camera moves 1 unit, noise texture sampling should swing by same amount.

	vec4 pos = vec4(interpolate3(position[0], position[1], position[2]), 1.0);
	vertex_height = tz::math::clamp(tz::noise::simplex((pos.xz + cam_pos.xz) / 300.0f), 0.0f, 1.0f);
	pos.y = vertex_height * 60.0f;
	pos = interpolate4m(mvp[0], mvp[1], mvp[2]) * pos;
	out::position = pos;
}
