shader(type = tesseval);

import <math>

input(id = 0) vec3 position[];
input(id = 1) mat4 mvp[];
output(id = 0) vec4 vertex_colour;

vec3 interpolate3(vec3 v0, vec3 v1, vec3 v2)
{
	return vec3(in::tess_coord.x) * v0 + vec3(in::tess_coord.y) * v1 + vec3(in::tess_coord.z) * v2;
}

mat4 interpolate4m(mat4 m0, mat4 m1, mat4 m2)
{
	return in::tess_coord.x * m0 + in::tess_coord.y * m1 + in::tess_coord.z * m2;
}

// Gold Noise ©2015 dcerisano@standard3d.com
// - based on the Golden Ratio
// - uniform normalized distribution
// - fastest static noise generator function (also runs at low precision)
// - use with indicated fractional seeding method. 

const float PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   

float gold_noise(vec2 xy, float seed){
       return tz::math::fract(tz::math::tan(tz::math::distance(xy*PHI, xy)*seed)*xy.x);
}

vec4 get_colour(vec2 uv)
{
	return vec4(gold_noise(uv, 1.0f), gold_noise(uv, 109.0f), gold_noise(uv, 13487.0f), 1.0f);
}

void main()
{
	vec4 pos = vec4(interpolate3(position[0], position[1], position[2]), 1.0);
	vertex_colour = get_colour(pos.xz) * 2.0f;

	tz_printf("before pos = %v4f", pos);
	pos.y = vertex_colour.r * 10.0f;
	pos = interpolate4m(mvp[0], mvp[1], mvp[2]) * pos;
	tz_printf("after pos = %v4f", pos);
	out::position = pos;
}
