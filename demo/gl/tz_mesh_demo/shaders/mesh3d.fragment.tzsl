shader(type = fragment);

import "texcount"

struct texture_t
{
	vec3 tint;
	uint texid;
};

output(id = 0) vec4 out::colour;
input(id = 0) vec2 in::texc;
input(id = 1) vec3 in::norm;
input(id = 2, flat) texture_t in::textures[TEX_COUNT];
resource(id = 3) const texture textures[];

void main()
{
	out::colour = vec4(vec3(0.0f), 1.0f);
		
	texture_t colour_tex = in::textures[0];
	vec3 tex_colour = texture(textures[colour_tex.texid], in::texc).xyz * colour_tex.tint;

	texture_t normal_tex = in::textures[1];
	vec3 norm = in::norm;
	if(normal_tex.texid != 0)
	{
		vec3 sampled_normal = texture(textures[normal_tex.texid], in::texc).xyz;
		vec3 tangent_normal = normalize(norm);
		vec3 binormal = cross(vec3(0.0f, 1.0f, 0.0f), tangent_normal);
		vec3 tangent = cross(tangent_normal, binormal);
		mat3 tbn = mat3(tangent, binormal, tangent_normal);
		norm = normalize(tbn * sampled_normal);
	}

	// we're gonna do some quick and dirty lighting here. basic phong.
	// our inputs are `colour_tex`, `norm` and some hardcoded values here.
	const float ambient_amt = 0.3f;
	vec3 ambient_col = tex_colour * ambient_amt;

	const vec3 light_direction = normalize(vec3(0.1f, 0.5f, 0.1f));
	const vec3 light_colour = vec3(1.0f);
	vec3 N = normalize(norm);
	vec3 L = normalize(light_direction);
	float diffuse_intensity = max(dot(N, L), 0.0f);
	vec3 diffuse_col = tex_colour * light_colour * diffuse_intensity;

	out::colour.xyz = ambient_col + diffuse_col;
}
