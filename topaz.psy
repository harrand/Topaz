ogl_debug_callback ::= func(source : s32, type : s32, id : u32, severity : s32, length : u32, msg : u8 mut&) -> v0
{
	puts(msg);
	__debugbreak();
};

wrangle_window_class ::= macro() -> v0
{
	register_wndclass();
	defer unregister_wndclass();
};

setup_arenas ::= macro() -> v0
{
	permanent_arena_val : arena mut := arena_create(4096 * 1024);
	permanent_arena ::= ref permanent_arena_val;
	defer puts("arena free: ");
	defer putuint(permanent_arena_val.cursor);
	defer puts("B");
	defer putchar(10);
	defer arena_destroy(permanent_arena_val);

	frame_arena_val : arena mut := arena_create(4096 * 1024);
	frame_arena ::= ref frame_arena_val;
	defer arena_destroy(frame_arena_val);
};

single_draw ::= struct
{
	count : u32;
	command : tz_gpu_draw_indexed_indirect_command;
};

main ::= func() -> s32
{
	wrangle_window_class();
	setup_arenas();

	print("type of '5' = ");
	print(__typename(5));
	print(' ');
	putchar(10);

	wnd ::= tz_wnd_open_window(800, 600, "Topaz Test", permanent_arena);
	defer tz_wnd_close_window(wnd);

	puts("watch as i count to 10!");
	putchar(10);
	counter : u64 mut;
	for(counter = 0, counter <= 10, counter = counter + 1)
	{
		putuint(counter);
		putchar(10);
	}

	tz_gpu_init(tz_gpu_appinfo
	{
		.name := "Topaz";
		.ver_maj := 6;
		.ver_min := 0;
	});

	hardware_count ::= tz_gpu_hardware_count();
	puts("hardware count: ");
	putuint(hardware_count);
	putchar(10);

	hardware_list : tz_gpu_hardware mut& := arena_push_one(permanent_arena, tz_gpu_hardware{});
	tz_gpu_iterate_hardware(hardware_list, hardware_count, permanent_arena);
	tz_gpu_use_hardware(deref(hardware_list at 0), wnd);

	pos : vec4 mut := vec4{.x := 0.0; .y := 0.0; .z := 0.0; .w := 0.0;};

	drawdata ::= single_draw
	{
		.count := 1;
		.command := tz_gpu_draw_indexed_indirect_command
		{
			.index_count := 3;
			.instance_count := 1;
			.first_index := 0;
			.vertex_offset := 0;
			.first_instance := 0;
		};
	};

	drawbuf ::= tz_gpu_create_buffer(tz_gpu_resource_info
	{
		.data := ref drawdata;
		.data_size := __sizeof(drawdata);
		.flags := tz_gpu_resource_flag.none;
		.buffer_flags := (tz_gpu_buffer_flag.draw_buffer);
	}, permanent_arena);

	buf ::= tz_gpu_create_buffer(tz_gpu_resource_info
	{
		.data := ref pos;
		.data_size := __sizeof(pos);
		.flags := tz_gpu_resource_flag.none;
		.buffer_flags := tz_gpu_buffer_flag.dynamic;
	}, permanent_arena);

	indices : u32 mut#3;
	deref(indices at 0) = 0;
	deref(indices at 1) = 1;
	deref(indices at 2) = 2;

	idxbuf ::= tz_gpu_create_buffer(tz_gpu_resource_info
	{
		.data := indices at 0;
		.data_size := __sizeof(indices);
		.flags := tz_gpu_resource_flag.none;
		.buffer_flags := tz_gpu_buffer_flag.index_buffer;
	}, permanent_arena);

	imgdata : u32 mut#4;
	deref(imgdata at 0) = 0xFFFF0000;
	deref(imgdata at 1) = 0xFF0000FF;
	deref(imgdata at 2) = 0xFF0000FF;
	deref(imgdata at 3) = 0xFFFF0000;

	img ::= tz_gpu_create_image(tz_gpu_resource_info
	{
		.data := imgdata at 0;
		.data_size := __sizeof(imgdata);
		.image_dimensions := vec2u32{.x := 2; .y := 2;};
		.image_type := tz_gpu_image_type.rgba;
		.flags := tz_gpu_resource_flag.none;
	}, permanent_arena);

	gpu_resources : tz_gpu_resource mut#2;
	deref(gpu_resources at 0) = buf;
	deref(gpu_resources at 1) = img;

	if(buf == (tz_gpu_resource.invalid))
	{
		puts("failed to create buffer");
		__debugbreak();
	}
	puts("buffer resource handle: ");
	putuint(buf@s64);
	putchar(10);

	shader_data ::= tz_gpu_load_shader_files("build/vertex.spv", "build/fragment.spv", permanent_arena);
	shader ::= tz_gpu_create_graphics_shader(shader_data.vertex_spv_data, shader_data.vertex_spv_count, shader_data.fragment_spv_data, shader_data.fragment_spv_count, permanent_arena);
	if(shader == (tz_gpu_shader.invalid))
	{
		puts("failed to create shader");
		__debugbreak();
	}

	colour_target ::= tz_gpu_resource.window_resource;

	pass ::= tz_gpu_create_pass(tz_gpu_pass_info
	{
		.graphics := tz_gpu_graphics_state
		{
			.clear_colour := vec4{.x := 0.7; .y := 0.5; .z := 0.0; .w := 1.0;};
			.scissor := vec4u32_zero();
			.colour_targets_data := ref colour_target;
			.colour_targets_count := 1;
			.depth_target := tz_gpu_resource.invalid;
			.index_buffer := idxbuf;
			.draw_buffer := drawbuf;
			.culling := tz_gpu_cull.none;
			.static_tri_count := 1;
		};
		.shader := shader;
		.resources_data := gpu_resources at 0;
		.resources_count := 2;
		.name := "Triangle Renderer";
	}, permanent_arena, frame_arena);
	if(pass == (tz_gpu_pass.invalid))
	{
		puts("failed to create pass");
		__debugbreak();
	}

	defer tz_gpu_term();

	tz_mesh_init(tz_mesh_config
	{
	}, permanent_arena);

	graph ::= tz_gpu_create_graph("triangle renderer", permanent_arena);
	tz_gpu_graph_add_pass(graph, tz_mesh_get_pass());
	tz_gpu_graph_add_pass(graph, tz_gpu_pass.present);

	mesh_vertices : tz_mesh_vertex mut#4;
	// Vertex positions (x, y, z) and texture coordinates (u, v)
	deref(mesh_vertices at 0) = tz_mesh_vertex{.pos := vec3{.x := -0.5; .y := -0.5; .z := 0.0;}; .texcoord := vec2{.x := 0.0; .y := 1.0;};};
	deref(mesh_vertices at 1) = tz_mesh_vertex{.pos := vec3{.x :=  0.5; .y := -0.5; .z := 0.0;}; .texcoord := vec2{.x := 1.0; .y := 1.0;};};
	deref(mesh_vertices at 2) = tz_mesh_vertex{.pos := vec3{.x := -0.5; .y :=  0.5; .z := 0.0;}; .texcoord := vec2{.x := 0.0; .y := 0.0;};};
	deref(mesh_vertices at 3) = tz_mesh_vertex{.pos := vec3{.x :=  0.5; .y :=  0.5; .z := 0.0;}; .texcoord := vec2{.x := 1.0; .y := 0.0;};};

	// Triangle indices
	mesh_indices : u32 mut#6;
	deref(mesh_indices at 0) = 0;
	deref(mesh_indices at 1) = 1;
	deref(mesh_indices at 2) = 2;
	deref(mesh_indices at 3) = 2;
	deref(mesh_indices at 4) = 1;
	deref(mesh_indices at 5) = 3;

	tz_mesh_upload(tz_mesh_data
	{
		.vertex_data := mesh_vertices at 0;
		.vertex_count := 4;
		.index_data := mesh_indices at 0;
		.index_count := 6;
	}, permanent_arena);

	while(tz_wnd_is_open(wnd))
	{
		if(frame_arena_val.cursor > 0)
		{
			/*
			puts("frame arena free: ");
			putuint(frame_arena_val.cursor);
			puts("B");
			putchar(10);
			*/
		}
		arena_clear(frame_arena);

		tz_gpu_execute(graph, permanent_arena, frame_arena);
		tz_wnd_update();
		if(is_key_down(key.escape))
		{
			puts("goodbye");
			putchar(10);
			tz_wnd_close_window(wnd);
		}
		speed ::= 0.0002;
		if(is_key_down(key.w))
		{
			pos.y = (pos.y + speed);
			tz_gpu_resource_write(buf, ref pos, __sizeof(vec4), 0);
		}
		if(is_key_down(key.s))
		{
			pos.y = (pos.y - speed);
			tz_gpu_resource_write(buf, ref pos, __sizeof(vec4), 0);
		}
		if(is_key_down(key.a))
		{
			pos.x = (pos.x - speed);
			tz_gpu_resource_write(buf, ref pos, __sizeof(vec4), 0);
		}
		if(is_key_down(key.d))
		{
			pos.x = (pos.x + speed);
			tz_gpu_resource_write(buf, ref pos, __sizeof(vec4), 0);
		}
		if(is_key_down(key.z))
		{
			tz_gpu_resize_buffer(buf, __sizeof(pos) * 2, permanent_arena, frame_arena);
		}
	}
	return 0;
};

== build ==
{
	add_source_file("src/debug.psy");
	add_source_file("src/tz_mesh.psy");
	add_source_file("src/tz_gpu.psy");
	add_source_file("src/keyboard.psy");
	add_source_file("src/tz_wnd.psy");

	set_output_directory("build");
	set_executable("tz");

	if static(__config() == "debug")
	{
		set_optimisation(0);
		enable_debug_symbols(true);
	}
	if static(__config() == "release")
	{
		set_optimisation(3);
		enable_debug_symbols(false);
	}

	run_command("glslc -o build/vertex.spv src/vertex.glsl");
	run_command("glslc -o build/fragment.spv src/fragment.glsl");
}
