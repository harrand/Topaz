<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Topaz: Passes</title>
<link rel="icon" href="tz.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="tz.png"/></td>
  <td id="projectalign">
   <div id="projectname">Topaz<span id="projectnumber">&#160;5.0</span>
   </div>
   <div id="projectbrief">Topaz Game Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">Passes<div class="ingroups"><a class="el" href="group__tz.html">API Reference</a> &raquo; <a class="el" href="group__tz__gpu.html">GPU Library</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Documentation for render/compute passes - each a single node within <a class="el" href="group__tz__gpu__graph.html">Graphs</a>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaeb0b7299626b0f12c51bc32981fd419d" id="r_gaeb0b7299626b0f12c51bc32981fd419d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">tz::gpu::pass_handle</a> = <a class="el" href="classtz_1_1handle.html">tz::handle</a>&lt;<a class="el" href="structtz_1_1gpu_1_1pass__info.html">pass_info</a>&gt;</td></tr>
<tr class="memdesc:gaeb0b7299626b0f12c51bc32981fd419d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corresponds to a previously-created pass.  <br /></td></tr>
<tr class="separator:gaeb0b7299626b0f12c51bc32981fd419d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtz_1_1gpu_1_1pass__graphics__state.html">tz::gpu::pass_graphics_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies creation flags for a new graphics pass.  <a href="structtz_1_1gpu_1_1pass__graphics__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtz_1_1gpu_1_1pass__compute__state.html">tz::gpu::pass_compute_state</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies creation flags for a new compute pass.  <a href="structtz_1_1gpu_1_1pass__compute__state.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtz_1_1gpu_1_1pass__info.html">tz::gpu::pass_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies creation flags for a new pass.  <a href="structtz_1_1gpu_1_1pass__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga30e151020820180ff5e63d7a3f354920" name="ga30e151020820180ff5e63d7a3f354920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30e151020820180ff5e63d7a3f354920">&#9670;&#160;</a></span>create_pass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::expected&lt; <a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a>, <a class="el" href="group__tz__core.html#ga98b356a4a54e1f49c9b3adb6002fc1af">tz::error_code</a> &gt; tz::gpu::create_pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtz_1_1gpu_1_1pass__info.html">pass_info</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new pass. </p>
<dl class="section return"><dt>Returns</dt><dd>On success: A <a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a> corresponding to the newly created pass. </dd>
<dd>
<a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afa24fe18195f0e29f8d3ef5ad3110cfc24">tz::error_code::invalid_value</a> If you fail to provide a valid shader program. </dd>
<dd>
<a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afa24fe18195f0e29f8d3ef5ad3110cfc24">tz::error_code::invalid_value</a> If you provide a malformed shader program. A shader program is only well-formed if it consists of only a compute shader, OR it consists of a single vertex and fragment shader. </dd>
<dd>
<a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afa24fe18195f0e29f8d3ef5ad3110cfc24">tz::error_code::invalid_value</a> For a graphics pass if you fail to provide at least one colour target. </dd>
<dd>
<a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afa24fe18195f0e29f8d3ef5ad3110cfc24">tz::error_code::invalid_value</a> For a graphics pass if you provide a colour target that is invalid. A valid colour target is either a.) the window resource (and you have opened a window), b.) an image resource created with <a class="el" href="group__tz__gpu__resource.html#ggac69ba8da4ab137995079556a00afa86ea167939444ca0bb293234fc31274fb659">tz::gpu::image_flag::colour_target</a> </dd>
<dd>
<a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afa71090755058a73a39e036d014dd51432">tz::error_code::precondition_failure</a> For a graphics pass if any colour target provided does not exactly match the dimensions of all other provided colour targets. All colour targets must be images with the same dimensions. This does mean that if you provide the window resource as a colour target, all other colour targets must have the same dimensions as the window. </dd>
<dd>
<a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afa04b68ae506f7169b8f4b697ca378cbda">tz::error_code::machine_unsuitable</a> If the currently-used hardware does not support the pass you're attempting to create, for example if you attempt to create a graphics pass but your hardware has <a class="el" href="group__tz__gpu__hardware.html#ggab2036c965f55d5a07205fa4fd2120e9cac503e1b23ae78f344e72b44606f5dfc6">hardware_capabilities::compute_only</a>. </dd>
<dd>
<a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afab64777a1172ff4005ed6cde9b70d7ca3">tz::error_code::oom</a> If CPU memory is exhausted while trying to create the pass. </dd>
<dd>
<a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afa4207af5812019b2c0ff52b4ff4339d4b">tz::error_code::voom</a> If GPU memory is exhausted while trying to create the pass.</dd></dl>
<p>Once you successfully create a pass, you can add it to a TODO: write docs on timelines</p>
<p>Once you're done with a pass, you can manually destroy it using <a class="el" href="#gafa24b4faf0daadfb7cfb1a8880f599d5">destroy_pass</a>. </p><dl class="section note"><dt>Note</dt><dd>If you never destroy a pass manually, it will automatically be destroyed for you when you call <a class="el" href="group__tz.html#ga0a5d1e375e7e82fcd12a8b74b8012bae">tz::terminate</a>. </dd></dl>

</div>
</div>
<a id="gadf35b21694f4b309a6a89724ab9227db" name="gadf35b21694f4b309a6a89724ab9227db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf35b21694f4b309a6a89724ab9227db">&#9670;&#160;</a></span>pass_set_triangle_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gpu::pass_set_triangle_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a></td>          <td class="paramname"><span class="paramname"><em>graphics_pass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>triangle_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the triangle count of an existing graphics pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphics_pass</td><td>Graphics pass to target. If you provide a compute pass, nothing interesting happens. </td></tr>
    <tr><td class="paramname">triangle_count</td><td>New number of triangles to render every frame.</td></tr>
  </table>
  </dd>
</dl>
<p>When you created a graphics pass, you set an initial triangle count via <a class="el" href="structtz_1_1gpu_1_1pass__graphics__state.html#ae9065866d3bc1f2f6ac5eec6c07dd2d7">pass_graphics_state::triangle_count</a>. This function will override that count, meaning the next time a pass submits GPU work, the new number of triangles will be rendered.</p>
<p>There are no GPU-sync considerations involved when calling this function. </p><dl class="section warning"><dt>Warning</dt><dd>If you fail to pass a valid <a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a> to this function, the behaviour is undefined. </dd></dl>

</div>
</div>
<a id="ga1e2a5f9b4f20558788905688e6b402ff" name="ga1e2a5f9b4f20558788905688e6b402ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e2a5f9b4f20558788905688e6b402ff">&#9670;&#160;</a></span>pass_set_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gpu::pass_set_kernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a></td>          <td class="paramname"><span class="paramname"><em>compute_pass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tz__core__math.html#ga31f6571a45149f2b4d229496156087c0">tz::v3u</a></td>          <td class="paramname"><span class="paramname"><em>kernel</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the compute kernel of an existing compute pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compute_pass</td><td>Compute pass to target. If you provide a graphics pass, nothing interesting happens. </td></tr>
    <tr><td class="paramname">kernel</td><td>New workgroup dimensions to be dispatched every frame.</td></tr>
  </table>
  </dd>
</dl>
<p>When you created a compute pass, you set an initial kernel size via <a class="el" href="structtz_1_1gpu_1_1pass__compute__state.html#a57943e7334b19c77ed5f6ee8d4ec9c63">pass_compute_state::kernel</a>. This function will override those dimensions, meaning the next time a pass submits GPU work, the new workgroup dimensions will be dispatched.</p>
<p>There are no GPU-sync considerations involved when calling this function. </p><dl class="section warning"><dt>Warning</dt><dd>If you fail to pass a valid <a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a> to this function, the behaviour is undefined. </dd></dl>

</div>
</div>
<a id="gaab0696a4eb7ef536038868a5804a8125" name="gaab0696a4eb7ef536038868a5804a8125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab0696a4eb7ef536038868a5804a8125">&#9670;&#160;</a></span>pass_set_scissor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gpu::pass_set_scissor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a></td>          <td class="paramname"><span class="paramname"><em>graphics_pass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tz__core__math.html#ga4bcbd9601057ce4166edc693ace5380c">tz::v4u</a></td>          <td class="paramname"><span class="paramname"><em>scissor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the scissor rectangle of an existing graphics pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphics_pass</td><td>Graphics pass to target. If you provide a graphics pass, nothing interesting happens. </td></tr>
    <tr><td class="paramname">scissor</td><td>Scissor rectangle, see <a class="el" href="structtz_1_1gpu_1_1pass__graphics__state.html#a447c9a2cb82ea01cf39f583d75e1dae4">pass_graphics_state::scissor</a> for further details.</td></tr>
  </table>
  </dd>
</dl>
<p>When you created a graphics pass, you may or may not have explicitly set an initial scissor rectangle via <a class="el" href="structtz_1_1gpu_1_1pass__graphics__state.html#a447c9a2cb82ea01cf39f583d75e1dae4">pass_graphics_state::scissor</a>. This function will override those dimensions, meaning the next time a pass submits GPU work, the new scissor rectangle will be used.</p>
<p>There are no GPU-sync considerations involved when calling this function. </p><dl class="section warning"><dt>Warning</dt><dd>If you fail to pass a valid <a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a> to this function, the behaviour is undefined. </dd></dl>

</div>
</div>
<a id="gadc3cfdcac66fbb410af52fcf7b1ff953" name="gadc3cfdcac66fbb410af52fcf7b1ff953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc3cfdcac66fbb410af52fcf7b1ff953">&#9670;&#160;</a></span>pass_add_image_resource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__tz__core.html#ga98b356a4a54e1f49c9b3adb6002fc1af">tz::error_code</a> tz::gpu::pass_add_image_resource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a></td>          <td class="paramname"><span class="paramname"><em>pass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tz__gpu__resource.html#gaa033f019591c94352c14a3269cd3f608">resource_handle</a></td>          <td class="paramname"><span class="paramname"><em>res</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new image resource to be used in the pass. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afa24fe18195f0e29f8d3ef5ad3110cfc24">tz::error_code::invalid_value</a> If you fail to provide a valid image resource. Note that this excludes buffer resources, the window resource, and the null resource. </dd>
<dd>
<a class="el" href="group__tz__core.html#gga98b356a4a54e1f49c9b3adb6002fc1afa6592bef62853d098c86f7aa3bff9aecf">tz::error_code::driver_hazard</a> If there are too many images used by the pass already. Passes have an implementation-defined maximum image count that is guaranteed to be at least 4096.</dd></dl>
<p>This will permanently increase the number of resources used in the pass. It is not possible to change the shader used by a pass, so the shader associated with the pass is expected to conditionally use the new image id anyway.</p>
<p>All other resources used by the pass are unchanged. The index of this new image to be used in the shader will be equal to the previous number of images. </p>

</div>
</div>
<a id="gafa24b4faf0daadfb7cfb1a8880f599d5" name="gafa24b4faf0daadfb7cfb1a8880f599d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa24b4faf0daadfb7cfb1a8880f599d5">&#9670;&#160;</a></span>destroy_pass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gpu::destroy_pass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manually destroy a pass. </p>
<p>Passes can be quite heavy in the context of both CPU and GPU memory. This is due to internal components such as recorded command buffers, synchronisation primitives and compiled shader code.</p>
<p>Because of this, it might sometimes be necessary to manually destroy a pass once you are certain you have no further use of it. This will free up a bunch of CPU/GPU memory.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you fail to pass a valid <a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">pass_handle</a> to this function, the behaviour is undefined. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaeb0b7299626b0f12c51bc32981fd419d" name="gaeb0b7299626b0f12c51bc32981fd419d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb0b7299626b0f12c51bc32981fd419d">&#9670;&#160;</a></span>pass_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaeb0b7299626b0f12c51bc32981fd419d">tz::gpu::pass_handle</a> = <a class="el" href="classtz_1_1handle.html">tz::handle</a>&lt;<a class="el" href="structtz_1_1gpu_1_1pass__info.html">pass_info</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Corresponds to a previously-created pass. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga03a9b4db32a0fcf853e0b3f2c6cbfc3e" name="ga03a9b4db32a0fcf853e0b3f2c6cbfc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03a9b4db32a0fcf853e0b3f2c6cbfc3e">&#9670;&#160;</a></span>pass_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ga03a9b4db32a0fcf853e0b3f2c6cbfc3e">tz::gpu::pass_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes what kind of GPU work a pass will involve. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga03a9b4db32a0fcf853e0b3f2c6cbfc3ea9e5f0bb330344d580b9e30d338d6ab6d" name="gga03a9b4db32a0fcf853e0b3f2c6cbfc3ea9e5f0bb330344d580b9e30d338d6ab6d"></a>render&#160;</td><td class="fielddoc"><p>Render Pass - involves rendering some kind of geometry via a vertex and fragment shader. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga03a9b4db32a0fcf853e0b3f2c6cbfc3ea77e73f3a185e16d1f08ca5e057710b9d" name="gga03a9b4db32a0fcf853e0b3f2c6cbfc3ea77e73f3a185e16d1f08ca5e057710b9d"></a>compute&#160;</td><td class="fielddoc"><p>Compute Pass - involves bespoke GPU-side processing via a compute shader. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga76beda1933fb65f5b8d8806653ab5ed2" name="ga76beda1933fb65f5b8d8806653ab5ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76beda1933fb65f5b8d8806653ab5ed2">&#9670;&#160;</a></span>graphics_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga76beda1933fb65f5b8d8806653ab5ed2">tz::gpu::graphics_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies optional behaviours for a graphics pass. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga76beda1933fb65f5b8d8806653ab5ed2a07b90c315d4a99ef349a64b9fb54e747" name="gga76beda1933fb65f5b8d8806653ab5ed2a07b90c315d4a99ef349a64b9fb54e747"></a>dont_clear&#160;</td><td class="fielddoc"><p>Do not clear the colour target images prior to rendering - whatever data they held previously will be loaded prior to rendering. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76beda1933fb65f5b8d8806653ab5ed2ac7fdaefba6a67bcae3e74143977b07f4" name="gga76beda1933fb65f5b8d8806653ab5ed2ac7fdaefba6a67bcae3e74143977b07f4"></a>no_depth_test&#160;</td><td class="fielddoc"><p>Disable depth testing - i.e fragments that are behind another may still draw over it. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga76beda1933fb65f5b8d8806653ab5ed2a30f9639137965f02962aa47339c870c8" name="gga76beda1933fb65f5b8d8806653ab5ed2a30f9639137965f02962aa47339c870c8"></a>no_depth_write&#160;</td><td class="fielddoc"><p>Disable depth writes - i.e when a depth test is passed by a fragment, the old depth value is not overwritten, but stays as it was before. </p>
<dl class="section note"><dt>Note</dt><dd>Depth writes are always disabled if depth testing is disabled (see <a class="el" href="#gga76beda1933fb65f5b8d8806653ab5ed2ac7fdaefba6a67bcae3e74143977b07f4">graphics_flag::no_depth_test</a>). </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="ga6589e2e52a01e7636c35d868270d7b37" name="ga6589e2e52a01e7636c35d868270d7b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6589e2e52a01e7636c35d868270d7b37">&#9670;&#160;</a></span>cull</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ga6589e2e52a01e7636c35d868270d7b37">tz::gpu::cull</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies face culling behaviour of a graphics pass. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6589e2e52a01e7636c35d868270d7b37af6cb3e816496528d4187db53bc66567f" name="gga6589e2e52a01e7636c35d868270d7b37af6cb3e816496528d4187db53bc66567f"></a>both&#160;</td><td class="fielddoc"><p>Cull front and back faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6589e2e52a01e7636c35d868270d7b37ae6ec529ba185279aa0adcf93e645c7cd" name="gga6589e2e52a01e7636c35d868270d7b37ae6ec529ba185279aa0adcf93e645c7cd"></a>front&#160;</td><td class="fielddoc"><p>Cull the front face. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6589e2e52a01e7636c35d868270d7b37a469bba0a564235dfceede42db14f17b0" name="gga6589e2e52a01e7636c35d868270d7b37a469bba0a564235dfceede42db14f17b0"></a>back&#160;</td><td class="fielddoc"><p>Cull the back face. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6589e2e52a01e7636c35d868270d7b37a334c4a4c42fdb79d7ebc3e73b517e6f8" name="gga6589e2e52a01e7636c35d868270d7b37a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"><p>Do not perform any face culling. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga0925cc29143a1c20819479b7a446cc55" name="ga0925cc29143a1c20819479b7a446cc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0925cc29143a1c20819479b7a446cc55">&#9670;&#160;</a></span>present_pass</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto tz::gpu::present_pass = static_cast&lt;tz::hanval&gt;(std::numeric_limits&lt;std::underlying_type_t&lt;tz::hanval&gt;&gt;::max() - 1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Meta-pass that acts as an action to present the system image to the screen. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
