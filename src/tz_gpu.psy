tz_gpu_appinfo ::= struct
{
	name : u8&;
	ver_maj : u32;
	ver_min : u32;
};

tz_gpu_err ::= enum
{
	.none := 0;
	.unknown := 1;
};

tz_gpu_hardware_type ::= enum
{
	.gpu := 0;
	.igpu := 1;
	.cpu := 2;
	.unknown := 3;
};

tz_gpu_hardware_caps ::= enum
{
	.graphics_compute := 0;
	.graphics_only := 1;
	.compute_only := 2;
	.none := 3;
};

tz_gpu_hardware ::= struct
{
	name : string;
	target_heap : u64;
	vram_size_mib : u64;
	type : tz_gpu_hardware_type;
	caps : tz_gpu_hardware_caps;
	id : u32;
	native_handle : u64;
};

frame_data ::= struct
{
	cpool : u64;
	cmds : u64;
};

// globals.
[[private]]
frame_overlap ::= 2;
frames : frame_data mut#2;
[[private]]
vkinst : u64 mut;
[[private]]
used_device : u64 mut;
[[private]]
used_hardware : u64 mut;
[[private]]
used_qfi : u32 mut;
[[private]]
graphics_queue : u64 mut;
[[private]]
compute_queue : u64 mut;

[[private]]
surface : u64 mut := 0;
[[private]]
swapchain : u64 mut := 0;
[[private]]
swapchain_width : u64 mut := 0;
[[private]]
swapchain_height : u64 mut := 0;

// implementation details

[[private]]
impl_need_swapchain ::= func(w : u64, h : u64, wnd : window_handle) -> VkResult
{
	if(surface == 0)
	{
		// create surface.
		if static(__is_windows)
		{
			create ::= VkWin32SurfaceCreateInfoKHR
			{
				.sType := 1000009000;
				.pNext := null;
				.flags := 0;
				.hinstance := GetModuleHandleA(null);
				.hwnd := wnd@s64@u64;
			};
			vk_check(vk.create_win32_surface_khr(vkinst, ref create, null, ref surface));
		}
		if static(__is_linux)
		{
			__error("linux vulkan support NYI");
		}
	}

	if(swapchain_width@_ == w)
	{
		if(swapchain_height@_ == h)
		{
			return VkResult.VK_SUCCESS;
		}
	}

	caps : VkSurfaceCapabilitiesKHR mut;
	vk.get_physical_device_surface_capabilities_khr(used_hardware, surface, ref caps);

	swch_create ::= VkSwapchainCreateInfoKHR
	{
		.sType := 1000001000;
		.pNext := null;
		.flags := 0;
		.surface := surface;
		.minImageCount := 2;
		.imageFormat := 44;
		.imageColorSpace := 0;
		.imageExtent := VkExtent2D{.width := 800; .height := 600;};
		.imageArrayLayers := 1;
		.imageUsage := (0x00000010 | 0x00000002);
		.imageSharingMode := 0;
		.queueFamilyIndexCount := 1;
		.pQueueFamilyIndices := ref used_qfi;
		.preTransform := caps.currentTransform;
		.compositeAlpha := 0x00000001;
		// 0 = immediate. fifo (vsync) = 2
		.presentMode := 0;
		.clipped := 0;
		.oldSwapchain := swapchain;
	};
	old_swapchain ::= swapchain;
	vk_check(vk.create_swapchain_khr(used_device, ref swch_create, null, ref swapchain));

	// get physical device.
	// create swapchain.
	// create swapchain images and views.
	// set swapchain_width and height to the new values.
	// create system image and system depth image.

	return VkResult.VK_SUCCESS;
};

[[private]]
impl_force_new_swapchain ::= func(wnd : window_handle) -> VkResult
{
	w ::= swapchain_width;
	h ::= swapchain_height;
	swapchain_width = 0;
	swapchain_height = 0;
	return impl_need_swapchain(w, h, wnd);
};


[[private]]
impl_fill_hardware_info ::= func(hw : tz_gpu_hardware mut&, pdev : u64, a : arena mut&) -> v0
{
	props : VkPhysicalDeviceProperties mut;
	vk.get_physical_device_properties(pdev, ref props);
	memprops : VkPhysicalDeviceMemoryProperties mut;
	vk.get_physical_device_memory_properties(pdev, ref memprops);

	(hw->id) = -1;
	(hw->native_handle) = pdev;
	(hw->vram_size_mib) = 0;
	(hw->target_heap) = 0;

	(hw->type) = (tz_gpu_hardware_type.unknown);
	if(props.deviceType == 0x01)
	{
		(hw->type) = (tz_gpu_hardware_type.igpu);
	}
	if(props.deviceType == 0x02)
	{
		(hw->type) = (tz_gpu_hardware_type.gpu);
	}
	if(props.deviceType == 0x04)
	{
		(hw->type) = (tz_gpu_hardware_type.cpu);
	}
	counter : u32 mut := 0;

	cur_vk_heap : VkMemoryHeap mut;
	cur_mem_ty : VkMemoryType mut;

	max_mem : u64 mut := 0;
	size : u64 mut := 0;
	while(counter < (memprops.memoryHeapCount))
	{
		cur_vk_heap = deref(memprops.memoryHeaps at counter);
		cur_mem_ty = deref(memprops.memoryTypes at counter);

		size = 0;
		if(cur_vk_heap.flags & 1)
		{
			size = (cur_vk_heap.size) / (1024 * 1024);
		}
		if(size > max_mem)
		{
			max_mem = size;
			(hw->target_heap) = counter@_;
		}
		(hw->vram_size_mib) = (hw->vram_size_mib) + size;

		counter = counter + 1;
	}

	family_count : u32 mut := 0;
	vk.get_physical_device_queue_family_properties(pdev, ref family_count, null);
	families : VkQueueFamilyProperties mut& := arena_push(a, __sizeof(VkQueueFamilyProperties) * family_count);
	vk.get_physical_device_queue_family_properties(pdev, ref family_count, families);

	counter = 0;
	cur_fam : VkQueueFamilyProperties mut;
	while(counter < family_count)
	{
		// hw->idx should be set to the first graphics compute queue.
		cur_fam = deref(families at counter);
		if((cur_fam.queueFlags) & 0x03)
		{
			(hw->id) = counter;
			counter = family_count;
		}
		counter = counter + 1;
	}

	(hw->name) = create_string(props.deviceName at 0, a);
};

// api

tz_gpu_init ::= func(info : tz_gpu_appinfo) -> v0
{
	TZ_GPU_VERSION ::= VK_MAKE_API_VERSION(0, 0, 1, 0);
	vulkan_init();

	appinfo ::= VkApplicationInfo
	{
		.sType := 0;
		.pNext := null;
		.pApplicationName := info.name;
		.applicationVersion := VK_MAKE_API_VERSION(0, info.ver_maj, info.ver_min, 0);
		.pEngineName := "tz_gpu";
		.engineVersion := TZ_GPU_VERSION;
		.apiVersion := VK_MAKE_API_VERSION(0, 1, 3, 0);
	};

	extensions : u8& mut#3;
	deref(extensions at 0) = "VK_KHR_surface";
	if static(__is_windows)
	{
		deref(extensions at 1) = "VK_KHR_win32_surface";
	}
	if static(__is_linux)
	{
		deref(extensions at 1) = "VK_KHR_xlib_surface";
	}
	// todo: make VK_EXT_debug_utils optional.
	deref(extensions at 2) = "VK_EXT_debug_utils";
	extension_count : u32 := __sizeof(extensions) / __sizeof(u8&);

	layers : u8& mut#1;
	deref(layers at 0) = "VK_LAYER_KHRONOS_validation";

	create ::= VkInstanceCreateInfo
	{
		.sType := 1;
		.pNext := null;
		.flags := 0;
		.pApplicationInfo := ref appinfo;
		.enabledLayerCount := 1;
		.ppEnabledLayerNames := layers at 0;
		.enabledExtensionCount := extension_count;
		.ppEnabledExtensionNames := extensions at 0;
	};

	vk_check(vk.create_instance(ref create, null, ref vkinst));
	vulkan_load_functions(vkinst);
};

tz_gpu_term ::= func() -> v0
{
	counter : u64 mut := 0;
	frame_ptr : frame_data mut& mut;
	while(counter < frame_overlap)
	{
		frame_ptr = (frames at counter);
		if(frame_ptr->cpool != 0)
		{
			vk.destroy_command_pool(used_device, frame_ptr->cpool, null);
			(frame_ptr->cpool) = 0;
		}

		counter = counter + 1;
	}
	if(swapchain != 0)
	{
		vk.destroy_swapchain_khr(used_device, swapchain, null);
	}
	vk.destroy_device(used_device, null);
	if(surface != 0)
	{
		vk.destroy_surface_khr(vkinst, surface, null);
	}
	vk.destroy_instance(vkinst, null);
	vulkan_term();
};

tz_gpu_hardware_count ::= func() -> u64
{
	ret : u32 mut;
	vk_check(vk.enumerate_physical_devices(vkinst, ref ret, null));
	return ret@_;
};

tz_gpu_iterate_hardware ::= func(array : tz_gpu_hardware mut&, array_size : u64, a : arena mut&) -> tz_gpu_err
{
	// need an array of VkPhysicalDevices for vulkan to write into.
pdev_storage : u64 mut& := arena_push(a, __sizeof(u64) * array_size);
	physical_device_count : u32 mut := array_size@_;
	result ::= vk.enumerate_physical_devices(vkinst, ref physical_device_count, pdev_storage);
	if(result != 0)
	{
		return tz_gpu_err.unknown;
	}
	
	counter : u64 mut := 0;
	while(counter < array_size)
	{
		impl_fill_hardware_info(array at counter, deref(pdev_storage at counter), a);
		counter = (counter + 1);
	}
	return tz_gpu_err.none;
};

tz_gpu_use_hardware ::= func(hardware : tz_gpu_hardware) -> v0
{
	pdev ::= hardware.native_handle;
	queue_priority : f32 := 1.0;

	qcreate ::= VkDeviceQueueCreateInfo
	{
		.sType := 2;
		.pNext := null;
		.flags := 0;
		.queueFamilyIndex := hardware.id;
		.queueCount := 1;
		.pQueuePriorities := ref queue_priority;
	};

	features13 ::= VkPhysicalDeviceVulkan13Features
	{
		.sType := 53;
		.pNext := null;
		.robustImageAccess := 0;
		.inlineUniformBlock := 0;
		.descriptorBindingInlineUniformBlockUpdateAfterBind := 0;
		.pipelineCreationCacheControl := 0;
		.privateData := 0;
		.shaderDemoteToHelperInvocation := 0;
		.shaderTerminateInvocation := 0;
		.subgroupSizeControl := 0;
		.computeFullSubgroups := 0;
		.synchronization2 := 1;
		.textureCompressionASTC_HDR := 0;
		.shaderZeroInitializeWorkgroupMemory := 0;
		.dynamicRendering := 1;
		.shaderIntegerDotProduct := 0;
		.maintenance4 := 0;
	};

	features12 ::= VkPhysicalDeviceVulkan12Features 
	{
		.sType := 51;
		.pNext := (ref features13)@_;
		.samplerMirrorClampToEdge := 0;
		.drawIndirectCount := 1;
		.storageBuffer8BitAccess := 0;
		.uniformAndStorageBuffer8BitAccess := 0;
		.storagePushConstant8 := 0;
		.shaderBufferInt64Atomics := 0;
		.shaderSharedInt64Atomics := 0;
		.shaderFloat16 := 0;
		.shaderInt8 := 0;
		.descriptorIndexing := 1;
		.shaderInputAttachmentArrayDynamicIndexing := 0;
		.shaderUniformTexelBufferArrayDynamicIndexing := 0;
		.shaderStorageTexelBufferArrayDynamicIndexing := 0;
		.shaderUniformBufferArrayNonUniformIndexing := 0;
		.shaderSampledImageArrayNonUniformIndexing := 1;
		.shaderStorageBufferArrayNonUniformIndexing := 0;
		.shaderStorageImageArrayNonUniformIndexing := 0;
		.shaderInputAttachmentArrayNonUniformIndexing := 0;
		.shaderUniformTexelBufferArrayNonUniformIndexing := 0;
		.shaderStorageTexelBufferArrayNonUniformIndexing := 0;
		.descriptorBindingUniformBufferUpdateAfterBind := 0;
		.descriptorBindingSampledImageUpdateAfterBind := 1;
		.descriptorBindingStorageImageUpdateAfterBind := 0;
		.descriptorBindingStorageBufferUpdateAfterBind := 0;
		.descriptorBindingUniformTexelBufferUpdateAfterBind := 0;
		.descriptorBindingStorageTexelBufferUpdateAfterBind := 0;
		.descriptorBindingUpdateUnusedWhilePending := 1;
		.descriptorBindingPartiallyBound := 1;
		.descriptorBindingVariableDescriptorCount := 1;
		.runtimeDescriptorArray := 1;
		.samplerFilterMinmax := 0;
		.scalarBlockLayout := 0;
		.imagelessFramebuffer := 0;
		.uniformBufferStandardLayout := 0;
		.shaderSubgroupExtendedTypes := 0;
		.separateDepthStencilLayouts := 0;
		.hostQueryReset := 0;
		.timelineSemaphore := 1;
		.bufferDeviceAddress := 1;
		.bufferDeviceAddressCaptureReplay := 0;
		.bufferDeviceAddressMultiDevice := 0;
		.vulkanMemoryModel := 0;
		.vulkanMemoryModelDeviceScope := 0;
		.vulkanMemoryModelAvailabilityVisibilityChains := 0;
		.shaderOutputViewportIndex := 0;
		.shaderOutputLayer := 0;
		.subgroupBroadcastDynamicId := 0;
	};

	enabled_features ::= VkPhysicalDeviceFeatures2
	{
		.sType := 1000059000;
		.pNext := (ref features12)@_;
		.features := VkPhysicalDeviceFeatures
		{
			.robustBufferAccess := 0;
			.fullDrawIndexUint32 := 0;
			.imageCubeArray := 0;
			.independentBlend := 0;
			.geometryShader := 0;
			.tessellationShader := 0;
			.sampleRateShading := 0;
			.dualSrcBlend := 0;
			.logicOp := 0;
			.multiDrawIndirect := 0;
			.drawIndirectFirstInstance := 0;
			.depthClamp := 0;
			.depthBiasClamp := 0;
			.fillModeNonSolid := 0;
			.depthBounds := 0;
			.wideLines := 0;
			.largePoints := 0;
			.alphaToOne := 0;
			.multiViewport := 0;
			.samplerAnisotropy := 0;
			.textureCompressionETC2 := 0;
			.textureCompressionASTC_LDR := 0;
			.textureCompressionBC := 0;
			.occlusionQueryPrecise := 0;
			.pipelineStatisticsQuery := 0;
			.vertexPipelineStoresAndAtomics := 0;
			.fragmentStoresAndAtomics := 0;
			.shaderTessellationAndGeometryPointSize := 0;
			.shaderImageGatherExtended := 0;
			.shaderStorageImageExtendedFormats := 0;
			.shaderStorageImageMultisample := 0;
			.shaderStorageImageReadWithoutFormat := 0;
			.shaderStorageImageWriteWithoutFormat := 0;
			.shaderUniformBufferArrayDynamicIndexing := 0;
			.shaderSampledImageArrayDynamicIndexing := 0;
			.shaderStorageBufferArrayDynamicIndexing := 0;
			.shaderStorageImageArrayDynamicIndexing := 0;
			.shaderClipDistance := 0;
			.shaderCullDistance := 0;
			.shaderFloat64 := 0;
			.shaderInt64 := 0;
			.shaderInt16 := 0;
			.shaderResourceResidency := 0;
			.shaderResourceMinLod := 0;
			.sparseBinding := 0;
			.sparseResidencyBuffer := 0;
			.sparseResidencyImage2D := 0;
			.sparseResidencyImage3D := 0;
			.sparseResidency2Samples := 0;
			.sparseResidency4Samples := 0;
			.sparseResidency8Samples := 0;
			.sparseResidency16Samples := 0;
			.sparseResidencyAliased := 0;
			.variableMultisampleRate := 0;
			.inheritedQueries := 0;
		};
	};

	extensions : u8& mut#1;
	deref(extensions at 0) = "VK_KHR_swapchain";
	extension_count : u32 := __sizeof(extensions) / __sizeof(u8&);

	create ::= VkDeviceCreateInfo
	{
		.sType := 3;
		.pNext := (ref enabled_features)@_;
		.flags := 0;
		.queueCreateInfoCount := 1;
		.pQueueCreateInfos := (ref qcreate)@_;
		.enabledLayerCount := 0;
		.ppEnabledLayerNames := null;
		.enabledExtensionCount := extension_count;
		.ppEnabledExtensionNames := extensions at 0;
		.pEnabledFeatures := null;
	};

	vk_check(vk.create_device(pdev, ref create, null, ref used_device));
	used_hardware = pdev;
	used_qfi = hardware.id;

	vk.get_device_queue(used_device, used_qfi, 0, ref graphics_queue);
	vk.get_device_queue(used_device, used_qfi, 0, ref compute_queue);

	pool_create ::= VkCommandPoolCreateInfo
	{
		.sType := 39;
		.pNext := null;
		.flags := 0x02;
		.queueFamilyIndex := used_qfi;
	};
	
	counter : u64 mut := 0;
	frame_ptr : frame_data mut& mut;

	cmd_info : VkCommandBufferAllocateInfo mut := VkCommandBufferAllocateInfo
	{
		.sType := 40;
		.pNext := null;
		.commandPool := 0;
		.level := 0;
		.commandBufferCount := 1;
	};

	while(counter < frame_overlap)
	{
		frame_ptr = (frames at counter);
		vk_check(vk.create_command_pool(used_device, ref pool_create, null, ref (frame_ptr->cpool)));
		cmd_info.commandPool = (frame_ptr->cpool);
		vk_check(vk.allocate_command_buffers(used_device, ref cmd_info, ref (frame_ptr->cmds)));

		counter = counter + 1;
	}

	puts("using ");
	print_string(ref (hardware.name));
	putchar(10);
};

== build ==
{
	add_source_file("src/vulkan.psy");
	add_source_file("src/wnd.psy");
}
