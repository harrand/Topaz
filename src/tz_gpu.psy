tz_gpu_appinfo ::= struct
{
	name : u8&;
	ver_maj : u32;
	ver_min : u32;
};

tz_gpu_err ::= enum
{
	.none := 0;
	.unknown := 1;
};

tz_gpu_hardware_type ::= enum
{
	.gpu := 0;
	.igpu := 1;
	.cpu := 2;
	.unknown := 3;
};

tz_gpu_hardware_caps ::= enum
{
	.graphics_compute := 0;
	.graphics_only := 1;
	.compute_only := 2;
	.none := 3;
};

tz_gpu_hardware ::= struct
{
	name : string;
	target_heap : u64;
	vram_size_mib : u64;
	type : tz_gpu_hardware_type;
	caps : tz_gpu_hardware_caps;
};

// globals.
[[private]]
vkinst : u64 mut;

[[private]]
surface : u64 mut := 0;
[[private]]
swapchain : u64 mut := 0;
[[private]]
swapchain_width : u64 mut := 0;
[[private]]
swapchain_height : u64 mut := 0;

// implementation details

[[private]]
impl_need_swapchain ::= func(w : u64, h : u64, wnd : u64) -> VkResult
{
	res : s32 mut := 0;
	if(surface == 0)
	{
		// create surface.
		if static(__is_windows)
		{
			create ::= VkWin32SurfaceCreateInfoKHR{};
			res = vk.create_win32_surface_khr(vkinst, ref create, null, ref surface);
		}
		if static(__is_linux)
		{
			__error("linux vulkan support NYI");
		}
	}
	vk_check(res);

	if(swapchain_width@_ == w)
	{
		if(swapchain_height@_ == h)
		{
			return VkResult.VK_SUCCESS;
		}
	}

	// get physical device.
	// create swapchain.
	// create swapchain images and views.
	// set swapchain_width and height to the new values.
	// create system image and system depth image.

	return res@u64@_;
};

[[private]]
impl_force_new_swapchain ::= func(wnd : u64) -> VkResult
{
	w ::= swapchain_width;
	h ::= swapchain_height;
	swapchain_width = 0;
	swapchain_height = 0;
	return impl_need_swapchain(w, h, wnd);
};


[[private]]
impl_fill_hardware_info ::= func(hw : tz_gpu_hardware mut&, pdev : u64, a : arena mut&) -> v0
{
	props : VkPhysicalDeviceProperties mut;
	vk.get_physical_device_properties(pdev, ref props);
	memprops : VkPhysicalDeviceMemoryProperties mut;
	vk.get_physical_device_memory_properties(pdev, ref memprops);

	(hw->vram_size_mib) = 0;
	(hw->target_heap) = 0;

	(hw->type) = (tz_gpu_hardware_type.unknown);
	if(props.deviceType == 0x01)
	{
		(hw->type) = (tz_gpu_hardware_type.igpu);
	}
	if(props.deviceType == 0x02)
	{
		(hw->type) = (tz_gpu_hardware_type.gpu);
	}
	if(props.deviceType == 0x04)
	{
		(hw->type) = (tz_gpu_hardware_type.cpu);
	}
	counter : u32 mut := 0;

	cur_vk_heap : VkMemoryHeap mut;
	cur_mem_ty : VkMemoryType mut;

	max_mem : u64 mut := 0;
	size : u64 mut := 0;
	while(counter < (memprops.memoryHeapCount))
	{
		cur_vk_heap = deref(memprops.memoryHeaps at counter);
		cur_mem_ty = deref(memprops.memoryTypes at counter);

		size = 0;
		if(cur_vk_heap.flags & 1)
		{
			size = (cur_vk_heap.size) / (1024 * 1024);
		}
		if(size > max_mem)
		{
			max_mem = size;
			(hw->target_heap) = counter@_;
		}
		(hw->vram_size_mib) = (hw->vram_size_mib) + size;

		counter = counter + 1;
	}

	(hw->name) = create_string(props.deviceName at 0, a);
};

// api

tz_gpu_init ::= func(info : tz_gpu_appinfo) -> v0
{
	TZ_GPU_VERSION ::= VK_MAKE_API_VERSION(0, 0, 1, 0);
	vulkan_init();

	appinfo ::= VkApplicationInfo
	{
		.sType := 0;
		.pNext := null;
		.pApplicationName := info.name;
		.applicationVersion := VK_MAKE_API_VERSION(0, info.ver_maj, info.ver_min, 0);
		.pEngineName := "tz_gpu";
		.engineVersion := TZ_GPU_VERSION;
		.apiVersion := VK_MAKE_API_VERSION(0, 1, 3, 0);
	};

	create ::= VkInstanceCreateInfo
	{
		.sType := 1;
		.pNext := null;
		.flags := 0;
		.pApplicationInfo := ref appinfo;
		.enabledLayerCount := 0;
		.ppEnabledLayerNames := null;
		.enabledExtensionCount := 0;
		.ppEnabledExtensionNames := null;
	};

	vk_check(vk.create_instance(ref create, null, ref vkinst));
	vulkan_load_functions(vkinst);
};

tz_gpu_term ::= func() -> v0
{
	vk.destroy_instance(vkinst, null);
	vulkan_term();
};

tz_gpu_hardware_count ::= func() -> u64
{
	ret : u32 mut;
	vk_check(vk.enumerate_physical_devices(vkinst, ref ret, null));
	return ret@_;
};

tz_gpu_iterate_hardware ::= func(array : tz_gpu_hardware mut&, array_size : u64, a : arena mut&) -> tz_gpu_err
{
	// need an array of VkPhysicalDevices for vulkan to write into.
	pdev_storage : u64 mut& := arena_push(a, __sizeof(u64) * array_size);
	physical_device_count : u32 mut := array_size@_;
	result ::= vk.enumerate_physical_devices(vkinst, ref physical_device_count, pdev_storage);
	if(result != 0)
	{
		return tz_gpu_err.unknown;
	}
	
	counter : u64 mut := 0;
	while(counter < array_size)
	{
		impl_fill_hardware_info(array at counter, deref(pdev_storage at counter), a);
		counter = (counter + 1);
	}
	return tz_gpu_err.none;
};

== build ==
{
	add_source_file("src/vulkan.psy");
}
