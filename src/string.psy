tzstring ::= struct
{
	ptr : u8 mut&;
	len : u64;
};

cstrlen ::= func(cstr : u8&) -> u64
{
	c : u64 mut := 0;
	if(cstr == null)
	{
		return c;
	}
	while((deref (cstr at c)) != 0)
	{
		c = c + 1;
	}
	return c;
};

cstreql ::= func(lhs : u8&, rhs : u8&) -> bool
{
	llen ::= cstrlen(lhs);
	rlen ::= cstrlen(rhs);
	if(llen != rlen)
	{
		return false;
	}
	min : u64 mut := rlen;
	if(llen < rlen)
	{
		min = llen;
	}
	i : u64 mut := 0;
	lchr : u8 mut;
	rchr : u8 mut;
	while(i < min)
	{
		lchr = deref(lhs at i);
		rchr = deref(rhs at i);
		if(lchr != rchr)
		{
			return false;
		}
		i = i + 1;
	}
	return true;
};

to_tzstring ::= func(cstr : u8 mut&) -> tzstring
{
	return tzstring
	{
		.ptr := cstr;
		.len := cstrlen(cstr);
	};
};

strcpy ::= func(dst : u8 mut&, src : u8&, count : u64) -> v0
{
	i : u64 mut := 0;
	dstcpy : u8 mut& mut := dst;
	srccpy : u8& mut := src;
	while(i < count)
	{
		(deref dstcpy) = (deref srccpy);
		dstcpy = ((dstcpy@u64) + 1)@u8 mut& mut;
		srccpy = ((srccpy@u64) + 1)@u8& mut;
		i = i + 1;
	}
};

to_zstring ::= func(str : tzstring, a : arena mut&) -> u8&
{
	ptr ::= arena_push(a, str.len + 1);
	strcpy(ptr, str.ptr, str.len);
	deref (((ptr@u64) + str.len)@u8 mut&) = 0;
	return ptr;
};

create_string ::= func(size : u64, a : arena mut&) -> tzstring
{
	return tzstring
	{
		.ptr := arena_push(a, size);
		.len := size;
	};
};

string_copy ::=  func(str : tzstring, a : arena mut&) -> tzstring
{
	return create_string(str.len, a);
};

print_string ::= func(str : tzstring) -> v0
{
	i : u64 mut := 0;
	ptr : u8& mut;
	while(i < (str.len))
	{
		ptr = ((str.ptr)@u64 + i)@u8&;
		putchar(deref ptr);
		i = i + 1;
	}
};

puts ::= func(str : u8&) -> v0
{
	i : u64 mut := 0;
	len ::= cstrlen(str);
	chr : u8& mut := null;
	while(i < len)
	{
		chr = (str at i);
		putchar(deref chr);
		i = i + 1;
	}
};

== build ==
{
	add_source_file("src/arena.psy");
	add_source_file("src/io.psy");
}
