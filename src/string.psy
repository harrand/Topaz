cstrlen ::= func(cstr : u8&) -> u64
{
	c : u64 mut := 0;
	if(cstr == null)
	{
		return c;
	}
	while((deref (cstr at c)) != 0)
	{
		c = c + 1;
	}
	return c;
};

puts ::= func(str : u8&) -> v0
{
	i : u64 mut := 0;
	len ::= cstrlen(str);
	chr : u8& mut := null;
	while(i < len)
	{
		chr = (str at i);
		putchar(deref chr);
		i = i + 1;
	}
};

cstreql ::= func(lhs : u8&, rhs : u8&) -> bool
{
	llen ::= cstrlen(lhs);
	rlen ::= cstrlen(rhs);
	if(llen != rlen)
	{
		return false;
	}
	min : u64 mut := rlen;
	if(llen < rlen)
	{
		min = llen;
	}
	i : u64 mut := 0;
	lchr : u8 mut;
	rchr : u8 mut;
	while(i < min)
	{
		lchr = deref(lhs at i);
		rchr = deref(rhs at i);
		if(lchr != rchr)
		{
			return false;
		}
		i = i + 1;
	}
	return true;
};

strcpy ::= func(dst : u8 mut&, src : u8&, count : u64) -> v0
{
	i : u64 mut := 0;
	dstcpy : u8 mut& mut := dst;
	srccpy : u8& mut := src;
	while(i < count)
	{
		(deref dstcpy) = (deref srccpy);
		dstcpy = ((dstcpy@u64) + 1)@u8 mut& mut;
		srccpy = ((srccpy@u64) + 1)@u8& mut;
		i = i + 1;
	}
};

string_view ::= struct
{
	str : u8&;
	len : u64;
};

string ::= struct
{
	sso : u8 mut#32;
	data : u8 mut&;
	len : u64 mut;
	cap : u64 mut;
};

create_string ::= func(cstring : u8&, mem : arena mut&) -> string
{
	ret : string mut;
	ret.len = cstrlen(cstring);

	sso_size : u64 static := __sizeof(ret.sso) / __sizeof(u8);
	if(ret.len < sso_size)
	{
		// yes, sso is large enough.
		ret.data = null;
		strcpy((ret.sso) at 0, cstring, ret.len);
		ret.cap = sso_size;
		return ret;
	}
	// sso too small. need to alloc.
	ret.data = arena_push(mem, ret.len);
	ret.cap = ret.len;
	strcpy(ret.data, cstring, ret.len);
	return ret;
};

string_is_small ::= func(str : string&) -> bool
{
	sso_size : u64 static := __sizeof(str->sso) / __sizeof(u8);
	return str->len < sso_size;
};

print_string ::= func(str : string&) -> v0
{
	i : u64 mut := 0;
	len ::= str->len;

	dst : u8 mut& mut := str->data;
	if(string_is_small(str))
	{
		dst = (str->sso) at 0;
	}

	while(i < len)
	{
		putchar(deref(dst at i));
		i = i + 1;
	}
};

string_append ::= func(str : string mut&, append : string&, mem : arena mut&) -> v0
{
	if(append->len == 0)
	{
		return;
	}
	total_len ::= (str->len) + (append->len);
	old_data : u8& mut := str->data;
	if(old_data == null)
	{
		old_data = (str->sso) at 0;
	}
	old_len ::= str->len;

	append_data : u8& mut := append->data;
	if(append_data == null)
	{
		append_data = (append->sso) at 0;
	}

	if(total_len > (str->cap))
	{
		// we need to realloc.
		str->data = arena_push(mem, total_len);
		// copy back over the old bit
		strcpy(str->data, old_data, old_len);
		old_data = (str->data);
		str->cap = total_len;
	}
	// append the new bit.
	strcpy((old_data at old_len)@_, append_data, append->len);
	str->len = total_len;
};

string_append_cstr ::= func(str : string mut&, append : u8&, mem : arena mut&) -> v0
{
	fake_str : string mut := string{};
	fake_str.len = cstrlen(append);
	fake_str.data = append@_;
	string_append(str, ref fake_str, mem);
};

string_clear ::= func(str : string mut&) -> v0
{
	str->len = 0;
};

string_duplicate ::= func(str : string&, mem : arena mut&) -> string
{
	ret : string mut;
	ret.len = (str->len);
	if(string_is_small(str))
	{
		strcpy(ret.sso at 0, str->sso at 0, ret.len);
		ret.data = null;
		ret.cap = __sizeof(ret.sso) / __sizeof(u8);
		return ret;
	}
	ret.cap = ret.len;
	ret.data = arena_push(mem, ret.len);
	return ret;
};

string_at ::= func(str : string&, idx : u64) -> u8 mut&
{
	if(string_is_small(str))
	{
		return str->sso at idx;
	}
	return str->data at idx;
};

== build ==
{
	add_source_file("src/arena.psy");
	add_source_file("src/io.psy");
}
