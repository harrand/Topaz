fabs ::= func(x : f32 mut) -> f32
{
	if(x < 0.0)
	{
		x = -x;
	}
	return x;
};

fpow ::= func(x : f32, p : f32) -> f32
{
	c : f32 mut := 1;
	counter : u32 mut;
	for(counter = 0, counter < (p@u32), counter = counter + 1)
	{
		c = (c * x);
	}
	return c;
};

ffact ::= func(x : f32) -> f32
{
	ret : f32 mut := 1;
	counter : u32 mut;
	for(counter = 1, counter <= (x@u32), counter = counter + 1)
	{
		ret = (ret * (counter@f32));
	}
	return ret;
};

fsin ::= func(x : f32 mut) -> f32
{
	res : f32 mut := 0;
	pow : f32 mut := x;
	fact : f32 mut := 1;
	i : u32 mut;
	// note: 10 is not a large amount of steps. if x is very large then this isnt enough to converge.
	for(i = 0, i < 10, i = i + 1)
	{
		res = (res + (pow / fact));
		pow = (pow * (-x * x));
		fact = (fact * ((2 * (i + 1)) * (2 * (i + 1) + 1)));
	}
	return res;
};

fcos ::= func(x : f32 mut) -> f32
{
	res : f32 mut := 1;
	pow : f32 mut := x * x;
	fact : f32 mut := 2;
	i : u32 mut;
	// note: 10 iterations may not be enough for large x.
	for(i = 1, i < 10, i = i + 1)
	{
		res = (res - (pow / fact));
		pow = (pow * (-x * x));
		fact = (fact * ((2 * i) * (2 * i + 1)));
	}
	return res;
};

fsqrt ::= func(x : f32 mut) -> f32
{
    if (x <= 0) { return 0; } // Handle non-positive input safely

    y : f32 mut := x; // Initial guess
    i : u32 mut;

    // Perform 10 iterations of Newton's method
    for(i = 0, i < 10, i = i + 1)
    {
        y = (y + x / y) / 2;
    }
    
    return y;
};
