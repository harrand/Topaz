quat_identity ::= func() -> vec4
{
	return vec4
	{
		.x := 0.0;
		.y := 0.0;
		.z := 0.0;
		.w := 1.0;
	};
};

quat_from_axis_angle ::= func(axis : vec3, angle : f32) -> vec4
{
	return vec4
	{
		.x := (axis.x) * fsin(angle / 2.0);
		.y := (axis.y) * fsin(angle / 2.0);
		.z := (axis.z) * fsin(angle / 2.0);
		.w := fcos(angle / 2.0);
	};
};

quat_mul ::= func(lhs : vec4, rhs : vec4) -> vec4
{
	return vec4
	{
		.x := ((lhs.w) * (rhs.x)) + ((lhs.x) * (rhs.w)) + ((lhs.y) * (rhs.z)) - ((lhs.z) * (rhs.y));
		.y := ((lhs.w) * (rhs.y)) - ((lhs.x) * (rhs.z)) + ((lhs.y) * (rhs.w)) + ((lhs.z) * (rhs.x));
		.z := ((lhs.w) * (rhs.z)) + ((lhs.x) * (rhs.y)) - ((lhs.y) * (rhs.x)) + ((lhs.z) * (rhs.w));
		.w := ((lhs.w) * (rhs.w)) - ((lhs.x) * (rhs.x)) - ((lhs.y) * (rhs.y)) - ((lhs.z) * (rhs.z));
	};
};

quat_normalise ::= func(q : vec4 mut) -> vec4
{
	len ::= fsqrt(((q.x) * (q.x)) + ((q.y) * (q.y)) + ((q.z) * (q.z)) + ((q.w) * (q.w)));
	if(len == 0.0)
	{
		// real bad.
		return quat_identity();
	}

	i : u32 mut;
	q.x = ((q.x) / len);
	q.y = ((q.y) / len);
	q.z = ((q.z) / len);
	q.w = ((q.w) / len);

	return q;
};

quat_inverse ::= func(q : vec4 mut) -> vec4
{
	sqlen ::= ((q.x) * (q.x)) + ((q.y) * (q.y)) + ((q.z) * (q.z)) + ((q.w) * (q.w));
	q.x = ((-(q.x)) * sqlen);
	q.y = ((-(q.y)) * sqlen);
	q.z = ((-(q.z)) * sqlen);
	q.w = ((q.w) * sqlen);
	return q;
};

quat2matrix ::= func(q : vec4 mut) -> mat4
{
	q = quat_normalise(q);
    rot : mat4 mut := mat4_identity();

    xx ::= (q.x) * (q.x);
    yy ::= (q.y) * (q.y);
    zz ::= (q.z) * (q.z);
    ww ::= (q.w) * (q.w);

    xy ::= (q.x) * (q.y);
    xz ::= (q.x) * (q.z);
    xw ::= (q.x) * (q.w);
    yz ::= (q.y) * (q.z);
    yw ::= (q.y) * (q.w);
    zw ::= (q.z) * (q.w);

	deref((rot.data) at 0) = (1.0 - (2.0 * (yy + zz)));
    deref((rot.data) at 1) = (2.0 * (xy - zw));
    deref((rot.data) at 2) = (2.0 * (xz + yw));

    deref((rot.data) at 4) = (2.0 * (xy + zw));
    deref((rot.data) at 5) = (1.0 - (2.0 * (xx + zz)));
    deref((rot.data) at 6) = (2.0 * (yz - xw));

    deref((rot.data) at 8) = (2.0 * (xz - yw));
    deref((rot.data) at 9) = (2.0 * (yz + xw));
    deref((rot.data) at 10) = (1.0 - (2.0 * (xx + yy)));

    return rot;
};

== build ==
{
	add_source_file("mat.psy");
	add_source_file("vec.psy");
	add_source_file("trig.psy");
}
