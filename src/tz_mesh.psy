tz_mesh_vertex ::= struct
{
	pos : vec3;
	texcoord : vec2;
};

tz_mesh_config ::= struct
{
	clear_colour : vec4;
	object_extra_data_size : u64;
	// object buffer will, target SAM/reBAR memory.
	// enable this if you expect to update your object data often, including on a per-frame basis.
	objects_dynamic : bool;
};

tz_mesh_handle ::= enum
{
	.invalid := -1;
};

tz_mesh_locator ::= struct
{
	vertex_offset : u64;
	vertex_count : u64;
	index_offset : u64;
	index_count : u64;
};

tz_mesh_data ::= struct
{
	vertex_data : tz_mesh_vertex&;
	vertex_count : u64;
	index_data : u32&;
	index_count : u64;
};

tz_mesh_object_data ::= struct
{
	model_matrix : mat4;
};

[[private]]
vb : tz_gpu_resource mut;
[[private]]
vertex_cap : u64 mut;
[[private]]
ib : tz_gpu_resource mut;
[[private]]
index_cap : u64 mut;

[[private]]
db : tz_gpu_resource mut;
[[private]]
db_cap : u64 mut;
[[private]]
db_cursor : u64 mut;

[[private]]
ob : tz_gpu_resource mut;
[[private]]
ob_cap : u64 mut;

[[private]]
geometry_pass : tz_gpu_pass mut;
[[private]]
mesh_renderer_initialised : bool mut := false;
[[private]]
mesh_renderer_config : tz_mesh_config mut;

[[private]]
mesh_locators : tz_mesh_locator mut& mut;
[[private]]
mesh_locators_count : u64 mut;
[[private]]
mesh_locators_cap : u64 mut;

[[private]]
initial_draw_cap ::= 512;
[[private]]
initial_vertex_cap ::= 8192;
[[private]]
initial_index_cap ::= 8192;
[[private]]
initial_mesh_locator_cap ::= 64;

[[private]]
impl_initialise_renderer ::= func(a : arena mut&) -> v0
{
	vertex_cap = initial_vertex_cap;
	index_cap = initial_index_cap;

	vb = tz_gpu_create_buffer(tz_gpu_resource_info
	{
		.data := null;
		.data_size := vertex_cap * __sizeof(tz_mesh_vertex);
		.flags := tz_gpu_resource_flag.zero_memory;
		.buffer_flags := tz_gpu_buffer_flag.none;
	}, a);

	ib = tz_gpu_create_buffer(tz_gpu_resource_info
	{
		.data := null;
		.data_size := index_cap * __sizeof(u32);
		.flags := tz_gpu_resource_flag.zero_memory;
		.buffer_flags := tz_gpu_buffer_flag.index_buffer;
	}, a);

	db_cap = (__sizeof(u32) + (__sizeof(tz_gpu_draw_indexed_command) * initial_draw_cap));
	db_cursor = 0;
	db = tz_gpu_create_buffer(tz_gpu_resource_info
	{
		.data := null;
		.data_size := db_cap;
		.flags := tz_gpu_resource_flag.zero_memory;
		.buffer_flags := tz_gpu_buffer_flag.draw_buffer;
	}, a);

	ob_cap = (initial_draw_cap * (__sizeof(tz_mesh_object_data) + (mesh_renderer_config.object_extra_data_size)));
	ob_flags : tz_gpu_buffer_flag mut := tz_gpu_buffer_flag.none;
	if(mesh_renderer_config.objects_dynamic)
	{
		ob_flags = (tz_gpu_buffer_flag.dynamic);
	}
	ob = tz_gpu_create_buffer(tz_gpu_resource_info
	{
		.data := null;
		.data_size := ob_cap;
		.flags := tz_gpu_resource_flag.zero_memory;
		.buffer_flags := ob_flags;
	}, a);

	mesh_locators_count = 0;
	mesh_locators_cap = initial_mesh_locator_cap;
	mesh_locators = arena_push(a, __sizeof(tz_mesh_locator) * initial_mesh_locator_cap);

	shader_data ::= tz_gpu_load_shader_files("build/mesh_renderer_vertex.spv", "build/mesh_renderer_fragment.spv", a);
	shader ::= tz_gpu_create_graphics_shader(shader_data.vertex_spv_data, shader_data.vertex_spv_count, shader_data.fragment_spv_data, shader_data.fragment_spv_count, a);

	colour_targets : tz_gpu_resource mut& := arena_push(a, __sizeof(tz_gpu_resource) * 1);
	deref(colour_targets at 0) = (tz_gpu_resource.window_resource);

	geom_rescount ::= 2;
	geom_resources : tz_gpu_resource mut& := arena_push(a, __sizeof(tz_gpu_resource) * geom_rescount);
	deref(geom_resources at 0) = vb;
	deref(geom_resources at 1) = ob;

	geometry_pass = tz_gpu_create_pass(tz_gpu_pass_info
	{
		.graphics := tz_gpu_graphics_state
		{
			.clear_colour := mesh_renderer_config.clear_colour;
			.scissor := vec4u32_zero();
			.colour_targets_data := colour_targets at 0;
			.colour_targets_count := 1;
			.depth_target := tz_gpu_resource.invalid;
			.index_buffer := ib;
			.draw_buffer := db;
			.culling := tz_gpu_cull.none;
			.static_tri_count := 2;
		};
		.shader := shader;
		.resources_data := geom_resources;
		.resources_count := geom_rescount;
		.name := "Mesh Renderer";
	}, a, a);

	mesh_renderer_initialised = true;
};

[[private]]
impl_find_vertex_region ::= func(vtx_count : u64) -> u64
{
	current_offset : u64 mut := 0;

	counter : u64 mut;
	curloc : tz_mesh_locator mut;
	gap_size : u64 mut;
	for(counter = 0, counter < mesh_locators_count, counter = counter + 1)
	{
		curloc = deref(mesh_locators at counter);

		gap_size = ((curloc.vertex_offset) - current_offset);
		if(gap_size >= vtx_count)
		{
			return current_offset;
		}
		current_offset = (curloc.vertex_offset) + (curloc.vertex_count);
	}

	// current_offset now is at the very end of all the mesh locators.
	// maybe there's space for our new count here?

	if((vertex_cap - current_offset) >= vtx_count)
	{
		return current_offset;
	}

	return -1@u64;
};

[[private]]
impl_find_index_region ::= func(idx_count : u64) -> u64
{
	current_offset : u64 mut := 0;

	counter : u64 mut;
	curloc : tz_mesh_locator mut;
	gap_size : u64 mut;
	for(counter = 0, counter < mesh_locators_count, counter = counter + 1)
	{
		curloc = deref(mesh_locators at counter);

		gap_size = ((curloc.index_offset) - current_offset);
		if(gap_size >= idx_count)
		{
			return current_offset;
		}
		current_offset = (curloc.index_offset) + (curloc.index_count);
	}

	// current_offset now is at the very end of all the mesh locators.
	// maybe there's space for our new count here?

	if((index_cap - current_offset) >= idx_count)
	{
		return current_offset;
	}
	return -1@u64;
};

[[private]]
impl_write_mesh_data ::= func(loc : tz_mesh_locator, vertex_data : tz_mesh_vertex&, index_data : u32&) -> v0
{
	vb_offset ::= (loc.vertex_offset) * __sizeof(tz_mesh_vertex);
	vb_writelen ::= (loc.vertex_count) * __sizeof(tz_mesh_vertex);
	tz_gpu_resource_write(vb, vertex_data, vb_writelen, vb_offset);

	ib_offset ::= (loc.index_offset) * __sizeof(u32);
	ib_writelen ::= (loc.index_count) * __sizeof(u32);
	tz_gpu_resource_write(ib, index_data, ib_writelen, ib_offset);
};

tz_mesh_init ::= func(config : tz_mesh_config, a : arena mut&) -> v0
{
	mesh_renderer_config = config;
	impl_initialise_renderer(a);
};

tz_mesh_upload ::= func(mesh : tz_mesh_data, a : arena mut&) -> tz_mesh_handle
{
	if(!mesh_renderer_initialised)
	{
		puts("tz_mesh_init not called before using tz_mesh.");
		__debugbreak();
	}

	retid ::= mesh_locators_count;
	if(mesh_locators_count >= mesh_locators_cap)
	{
		puts("ran out of mesh locator capacity");
		__debugbreak();
	}
	locptr ::= mesh_locators at mesh_locators_count;
	mesh_locators_count = mesh_locators_count + 1;

	(locptr->vertex_offset) = impl_find_vertex_region(mesh.vertex_count);
	(locptr->vertex_count) = (mesh.vertex_count);
	(locptr->index_offset) = impl_find_index_region(mesh.index_count);
	(locptr->index_count) = (mesh.index_count);
	if((locptr->vertex_offset) == -1)
	{
		puts("ran out of vertex capacity");
		__debugbreak();
	}
	if((locptr->index_offset) == -1)
	{
		puts("ran out of index capacity");
		__debugbreak();
	}

	impl_write_mesh_data(deref locptr, mesh.vertex_data, mesh.index_data);

	return retid@tz_mesh_handle;
};

tz_mesh_add_to_draw_list ::= func(mesh : tz_mesh_handle, object_id : u64) -> v0
{
	if(db_cursor >= db_cap)
	{
		puts("ran out of draw list capacity");
		__debugbreak();
	}
	loc ::= deref(mesh_locators at (mesh@s64));
	new_draw_count : u32 := db_cursor + 1;
	tz_gpu_resource_write(db, ref new_draw_count, __sizeof(u32), 0);

	cmd_offset ::= __sizeof(u32) + (db_cursor * __sizeof(tz_gpu_draw_indexed_command));
	cmd ::= tz_gpu_draw_indexed_command
	{
		.index_count := (loc.index_count)@_;
		.instance_count := 1;
		.first_index := (loc.index_offset)@_;
		.vertex_offset := 0;
		.first_instance := object_id@_;
	};
	tz_gpu_resource_write(db, ref cmd, __sizeof(tz_gpu_draw_indexed_command), cmd_offset);

	db_cursor = new_draw_count@_;
};

tz_mesh_set_object_data ::= func(object_id : u64, base_data : tz_mesh_object_data, extra_data : v0& weak) -> v0
{
	extra_size ::= mesh_renderer_config.object_extra_data_size;
	base_size ::= __sizeof(tz_mesh_object_data);
	offset ::= object_id * (base_size + extra_size);
	tz_gpu_resource_write(ob, ref base_data, base_size, offset);
	if(extra_size > 0)
	{
		tz_gpu_resource_write(ob, extra_data, extra_size, offset + base_size);
	}
};

tz_mesh_get_pass ::= func() -> tz_gpu_pass
{
	return geometry_pass;
};

== build ==
{
	add_source_file("vec.psy");
	add_source_file("tz_gpu.psy");

	run_command("glslc -o build/mesh_renderer_vertex.spv src/mesh_renderer_vertex.glsl");
	run_command("glslc -o build/mesh_renderer_fragment.spv src/mesh_renderer_fragment.glsl");
}
