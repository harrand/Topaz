LoadLibraryA ::= func(lpLibFileName : u8&) -> u64 := extern;
FreeLibrary ::= func(hLibModule : u64) -> s32 := extern;
GetProcAddress ::= func(module : u64, lpProcName : u8&) -> u64 weak := extern;

// VkResult = s32 weak
VkApplicationInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	pApplicationName : u8&;
	applicationVersion : u32;
	pEngineName : u8&;
	engineVersion : u32;
	apiVersion : u32;
};

VkInstanceCreateInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	flags : s32 weak;
	pApplicationInfo : VkApplicationInfo&;
	enabledLayerCount : u32;
	ppEnabledLayerNames : u8&&;
	enabledExtensionCount : u32;
	ppEnabledExtensionNames : u8&&;
};

VkSystemAllocationScope ::= enum
{
	.COMMAND := 0;
	.OBJECT := 1;
	.CACHE := 2;
	.DEVICE := 3;
	.INSTANCE := 4;
};

VkInternalAllocationType ::= enum
{
	.EXECUTABLE := 0;
};

VkAllocationCallbacks ::= struct
{
	pUserData : v0&;
	pfnAllocationFunction : func(pUserData : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnReallocationFunction : func(pUserData : v0&, pOriginal : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnFreeFunction : func(pUserData : v0&, mem : v0&) -> v0;
	pfnInternalAllocation : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
	pfnInternalFree : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
};

if static(__is_windows)
{
	VkWin32SurfaceCreateInfoKHR ::= struct
	{
		sType : s32;
		pNext : v0&;
		flags : s32;
		hinstance : u64;
		hwnd : u64;
	};
}

VkPhysicalDeviceLimits ::= struct
{
	maxImageDimension1D : u32;
	maxImageDimension2D : u32;
	maxImageDimension3D : u32;
	maxImageDimensionCube : u32;
	maxImageArrayLayers : u32;
	maxTexelBufferElements : u32;
	maxUniformBufferRange : u32;
	maxStorageBufferRange : u32;
	maxPushConstantSize : u32;
	maxMemoryAllocationCount : u32;
	maxSamplerAllocationCount : u32;
	bufferImageGranularity : u64;
	sparseAddressSpaceSize : u64;
	maxBoundDescriptorSets : u32;
	maxPerStageDescriptorSamplers : u32;
	maxPerStageDescriptorUniformSamplers : u32;
	maxPerStageDescriptorStorageSamplers : u32;
	maxPerStageDescriptorSampledImages : u32;
	maxPerStageDescriptorStorageImages : u32;
	maxPerStageDescriptorInputAttachments : u32;
	maxPerStageResources : u32;
	maxDescriptorSetSamplers : u32;
	maxDescriptorSetUniformBuffers : u32;
	maxDescriptorSetUniformBuffersDynamic : u32;
	maxDescriptorSetStorageBuffers : u32;
	maxDescriptorSetStorageBuffersDynamic : u32;
	maxDescriptorSetSampledImages : u32;
	maxDescriptorSetStorageImages : u32;
	maxDescriptorSetInputAttachments : u32;
	maxVertexInputAttributes : u32;
	maxVertexInputBindings : u32;
	maxVertexInputAttributeOffset : u32;
	maxVertexInputBindingStride : u32;
	maxVertexOutputComponents : u32;
	maxTessellationGenerationLevel : u32;
	maxTessellationPatchSize : u32;
	maxTessellationControlPerVertexInputComponents : u32;
	maxTessellationControlPerVertexOutputComponents : u32;
	maxTessellationControlPerPatchOutputComponents : u32;
	maxTessellationControlTotalOutputComponents : u32;
	maxTessellationEvaluationInputComponents : u32;
	maxTessellationEvaluationOutputComponents : u32;
	maxGeometryShaderInvocations : u32;
	maxGeometryInputComponents : u32;
	maxGeometryOutputComponents : u32;
	maxGeometryOutputVertices : u32;
	maxGeometryTotalOutputComponents : u32;
	maxFragmentInputComponents : u32;
	maxFragmentOutputAttachments : u32;
	maxFragmentDualSrcAttachments : u32;
	maxFragmentCombinedOutputResources : u32;
	maxComputeSharedMemorySize : u32;
	maxComputeWorkGroupCount : u32#3;
	maxComputeWorkGroupInvocations : u32;
	maxComputeWorkGroupSize : u32#3;
	subPixelPrecisionBits : u32;
	subTexelPrecisionBits : u32;
	mipmapPrecisionBits : u32;
	maxDrawIndexedIndexValue : u32;
	maxDrawIndirectCount : u32;
	maxSamplerLodBias : f32;
	maxSamplerAnisotropy : f32;
	maxViewports : u32;
	maxViewportDimensions : u32#2;
	viewportBoundsRange : f32#2;
	viewportSubPixelBits : u32;
	minMemoryMapAlignment : u64;
	minTexelBufferOffsetAlignment : u64;
	minUniformBufferOffsetAlignment : u64;
	minStorageBufferOffsetAlignment : u64;
	minTexelOffset : s32;
	maxTexelOffset : u32;
	minTexelGatherOffset : s32;
	maxTexelGatherOffset : u32;
	minInterpolationOffset : f32;
	maxInterpolationOffset : f32;
	subPixelInterpolationOffsetBits : u32;
	maxFramebufferWidth : u32;
	maxFramebufferHeight : u32;
	maxFramebufferLayers : u32;
	framebufferColorSampleCounts : u32;
	framebufferDepthSampleCounts : u32;
	framebufferStencilSampleCounts : u32;
	framebufferNoAttachmentsSampleCounts : u32;
	maxColorAttachments : u32;
	sampledImageColorSampleCounts : u32;
	sampledImageIntegerSampleCounts : u32;
	sampledImageDepthSampleCounts : u32;
	sampledImageStencilSampleCounts : u32;
	storageImageSampleCounts : u32;
	maxSampleMaskWords : u32;
	timestampComputeAndGraphics : u32;
	timestampPeriod : f32;
	maxClipDistances : u32;
	maxCullDistances : u32;
	maxCombinedClipAndCullDistances : u32;
	discreteQueuePriorities : u32;
	pointSizeRange : f32#2;
	lineWidthRange : f32#2;
	pointSizeGranularity : f32;
	lineWidthGranularity : f32;
	strictLines : u32;
	standardSampleLocations : u32;
	optimalBufferCopyOffsetAlignment : u64;
	optimalBufferCopyRowPitchAlignment : u64;
	nonCoherentAtomSize : u64;
};

VkPhysicalDeviceSparseProperties ::= struct
{
	residencyStandard2DBlockShape : u32;
	residencyStandard2DMultisampleBlockShape : u32;
	residencyStandard3DBlockShape : u32;
	residencyAlignedMipSize : u32;
	residencyNonResidentStrict : u32;
};

VkPhysicalDeviceProperties ::= struct
{
	apiVersion : u32;
	driverVersion : u32;
	vendorID : u32;
	deviceID : u32;
	deviceType : s32;
	deviceName : u8#256;
	pipelineCacheUUID : u8#16;
	limits : VkPhysicalDeviceLimits;
	sparseProperties : VkPhysicalDeviceSparseProperties;
};

vk_functions_t ::= struct
{
	get_instance_proc_addr : func(instance : u64, funcname : u8&) -> u64 weak;
	create_instance : func(pCreateInfo : VkInstanceCreateInfo&, pAllocator : VkAllocationCallbacks&, pInstance : u64 mut&) -> s32;
	destroy_instance : func(instance : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	if static(__is_windows)
	{
		create_win32_surface_khr : func(instance : u64, pCreateInfo : VkWin32SurfaceCreateInfoKHR&, pAllocator : VkAllocationCallbacks&, surface : u64 mut&) -> s32;
	}

	enumerate_physical_devices : func(instance : u64, pPhysicalDeviceCount : u32 mut&, pPhysicalDevices : u64 mut&) -> s32;
	get_physical_device_properties : func(physicalDevice : u64, pProperties : VkPhysicalDeviceProperties mut&) -> v0;
};

vk : vk_functions_t mut;

vulkan_driver : u64 weak mut := -1;
vulkan_driver_initialised : bool mut := false;

load_vk_driver_fn ::= func(funcname : u8&, module : u64) -> u64 weak
{
	addr ::= GetProcAddress(module, funcname);
	if(addr == null)
	{
		puts("failed to load driver function ");
		puts(funcname);
		putchar(10);
		__debugbreak();
	}
	return addr;
};

load_vk_fn ::= func(funcname : u8&, instance : u64) -> u64 weak
{
	addr ::= vk.get_instance_proc_addr(instance, funcname);
	if(addr == null)
	{
		puts("failed to load function ");
		puts(funcname);
		putchar(10);
		__debugbreak();
	}
	return addr;
};

donestr ::= "done.\n";

vulkan_init ::= func() -> v0
{
	initialised_driver : bool mut := false;
	if(!vulkan_driver_initialised)
	{
		vulkan_driver = LoadLibraryA("vulkan-1.dll");
		if(vulkan_driver == 0)
		{
			__debugbreak();
		}
		puts("loading from vulkan driver...");
		vulkan_driver_initialised = true;
		initialised_driver = true;
	}
	defer puts(donestr);

	vk.create_instance = load_vk_driver_fn("vkCreateInstance", vulkan_driver);
	vk.destroy_instance = load_vk_driver_fn("vkDestroyInstance", vulkan_driver);
	vk.get_instance_proc_addr = load_vk_driver_fn("vkGetInstanceProcAddr", vulkan_driver);

	if static(__is_windows)
	{
		vk.create_win32_surface_khr = load_vk_driver_fn("vkCreateWin32SurfaceKHR", vulkan_driver);
	}
};

vulkan_load_functions ::= func(instance : u64) -> v0
{
	vk.enumerate_physical_devices = load_vk_fn("vkEnumeratePhysicalDevices", instance);
	vk.get_physical_device_properties = load_vk_fn("vkGetPhysicalDeviceProperties", instance);
};

vulkan_term ::= func() -> v0
{
	// let go of the vulkan driver.
	if(vulkan_driver_initialised)
	{
		FreeLibrary(vulkan_driver);
		vulkan_driver_initialised = false;
	}
};

VK_MAKE_API_VERSION ::= func(variant : u32 weak, major : u32 weak, minor : u32 weak, patch : u32 weak) -> u32
{
	return (variant * 536870912) | (major * 4194304) | (minor * 4096) | patch;
};

VkResult ::= enum
{
	.VK_SUCCESS := 0;
	.VK_NOT_READY := 1;
	.VK_TIMEOUT := 2;
	.VK_EVENT_SET := 3;
	.VK_EVENT_RESET := 4;
	.VK_INCOMPLETE := 5;
	.VK_ERROR_OUT_OF_HOST_MEMORY := -1;
	.VK_ERROR_OUT_OF_DEVICE_MEMORY := -2;
	.VK_ERROR_INITIALIZATION_FAILED := -3;
	.VK_ERROR_DEVICE_LOST := -4;
	.VK_ERROR_MEMORY_MAP_FAILED := -5;
	.VK_ERROR_LAYER_NOT_PRESENT := -6;
	.VK_ERROR_EXTENSION_NOT_PRESENT := -7;
	.VK_ERROR_FEATURE_NOT_PRESENT := -8;
	.VK_ERROR_INCOMPATIBLE_DRIVER := -9;
	.VK_ERROR_TOO_MANY_OBJECTS := -10;
	.VK_ERROR_FORMAT_NOT_SUPPORTED := -11;
	.VK_ERROR_FRAGMENTED_POOL := -12;
	.VK_ERROR_UNKNOWN := -13;
	.VK_ERROR_OUT_OF_POOL_MEMORY := -1000069000;
// Provided by VK_VERSION_1_1
	.VK_ERROR_INVALID_EXTERNAL_HANDLE := -1000072003;
// Provided by VK_VERSION_1_2
	.VK_ERROR_FRAGMENTATION := -1000161000;
// Provided by VK_VERSION_1_2
	.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS := -1000257000;
// Provided by VK_VERSION_1_3
	.VK_PIPELINE_COMPILE_REQUIRED := 1000297000;
// Provided by VK_VERSION_1_4
	.VK_ERROR_NOT_PERMITTED := -1000174001;
// Provided by VK_KHR_surface
	.VK_ERROR_SURFACE_LOST_KHR := -1000000000;
// Provided by VK_KHR_surface
	.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR := -1000000001;
// Provided by VK_KHR_swapchain
	.VK_SUBOPTIMAL_KHR := 1000001003;
// Provided by VK_KHR_swapchain
	.VK_ERROR_OUT_OF_DATE_KHR := -1000001004;
// Provided by VK_KHR_display_swapchain
	.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR := -1000003001;
// Provided by VK_EXT_debug_report
	.VK_ERROR_VALIDATION_FAILED_EXT := -1000011001;
// Provided by VK_NV_glsl_shader
	.VK_ERROR_INVALID_SHADER_NV := -1000012000;
// Provided by VK_KHR_video_queue
	.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR := -1000023000;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR := -1000023001;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR := -1000023002;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR := -1000023003;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR := -1000023004;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR := -1000023005;
// Provided by VK_EXT_image_drm_format_modifier
	.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT := -1000158000;
// Provided by VK_EXT_full_screen_exclusive
	.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT := -1000255000;
// Provided by VK_KHR_deferred_host_operations
	.VK_THREAD_IDLE_KHR := 1000268000;
// Provided by VK_KHR_deferred_host_operations
	.VK_THREAD_DONE_KHR := 1000268001;
// Provided by VK_KHR_deferred_host_operations
	.VK_OPERATION_DEFERRED_KHR := 1000268002;
// Provided by VK_KHR_deferred_host_operations
	.VK_OPERATION_NOT_DEFERRED_KHR := 1000268003;
// Provided by VK_KHR_video_encode_queue
	.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR := -1000299000;
// Provided by VK_EXT_image_compression_control
	.VK_ERROR_COMPRESSION_EXHAUSTED_EXT := -1000338000;
// Provided by VK_EXT_shader_object
	.VK_INCOMPATIBLE_SHADER_BINARY_EXT := 1000482000;
// Provided by VK_KHR_pipeline_binary
	.VK_PIPELINE_BINARY_MISSING_KHR := 1000483000;
// Provided by VK_KHR_pipeline_binary
	.VK_ERROR_NOT_ENOUGH_SPACE_KHR := -1000483000;
};

vk_check ::= func(result : s32) -> v0
{
	res ::= result@s64@VkResult;
	if(result != 0)
	{
		puts("vulkan call returned error code ");
		putsint(result);
		puts(" (");
		puts(__enumname(res));
		puts(")");
		putchar(10);
		__debugbreak();
	}
};


== build ==
{
	add_source_file("src/string.psy");
	add_link_library("Kernel32.lib");
}
