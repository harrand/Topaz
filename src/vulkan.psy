LoadLibraryA ::= func(lpLibFileName : u8&) -> u64 := extern;
FreeLibrary ::= func(hLibModule : u64) -> s32 := extern;
GetProcAddress ::= func(module : u64, lpProcName : u8&) -> u64 weak := extern;

// VkResult = s32 weak
VkApplicationInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	pApplicationName : u8&;
	applicationVersion : u32;
	pEngineName : u8&;
	engineVersion : u32;
	apiVersion : u32;
};

VkInstanceCreateInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	flags : s32 weak;
	pApplicationInfo : VkApplicationInfo&;
	enabledLayerCount : u32;
	ppEnabledLayerNames : u8&&;
	enabledExtensionCount : u32;
	ppEnabledExtensionNames : u8&&;
};

VkSystemAllocationScope ::= enum
{
	.COMMAND := 0;
	.OBJECT := 1;
	.CACHE := 2;
	.DEVICE := 3;
	.INSTANCE := 4;
};

VkInternalAllocationType ::= enum
{
	.EXECUTABLE := 0;
};

VkAllocationCallbacks ::= struct
{
	pUserData : v0&;
	pfnAllocationFunction : func(pUserData : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnReallocationFunction : func(pUserData : v0&, pOriginal : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnFreeFunction : func(pUserData : v0&, mem : v0&) -> v0;
	pfnInternalAllocation : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
	pfnInternalFree : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
};

VkMemoryAllocateFlagsInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	deviceMask : u32;
};

VkMemoryAllocateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	allocationSize : u64;
	memoryTypeIndex : u32;
};

if static(__is_windows)
{
	VkWin32SurfaceCreateInfoKHR ::= struct
	{
		sType : s32;
		pNext : v0&;
		flags : s32;
		hinstance : u64;
		hwnd : u64;
	};
}

VkPhysicalDeviceLimits ::= struct
{
	maxImageDimension1D : u32;
	maxImageDimension2D : u32;
	maxImageDimension3D : u32;
	maxImageDimensionCube : u32;
	maxImageArrayLayers : u32;
	maxTexelBufferElements : u32;
	maxUniformBufferRange : u32;
	maxStorageBufferRange : u32;
	maxPushConstantSize : u32;
	maxMemoryAllocationCount : u32;
	maxSamplerAllocationCount : u32;
	bufferImageGranularity : u64;
	sparseAddressSpaceSize : u64;
	maxBoundDescriptorSets : u32;
	maxPerStageDescriptorSamplers : u32;
	maxPerStageDescriptorUniformSamplers : u32;
	maxPerStageDescriptorStorageSamplers : u32;
	maxPerStageDescriptorSampledImages : u32;
	maxPerStageDescriptorStorageImages : u32;
	maxPerStageDescriptorInputAttachments : u32;
	maxPerStageResources : u32;
	maxDescriptorSetSamplers : u32;
	maxDescriptorSetUniformBuffers : u32;
	maxDescriptorSetUniformBuffersDynamic : u32;
	maxDescriptorSetStorageBuffers : u32;
	maxDescriptorSetStorageBuffersDynamic : u32;
	maxDescriptorSetSampledImages : u32;
	maxDescriptorSetStorageImages : u32;
	maxDescriptorSetInputAttachments : u32;
	maxVertexInputAttributes : u32;
	maxVertexInputBindings : u32;
	maxVertexInputAttributeOffset : u32;
	maxVertexInputBindingStride : u32;
	maxVertexOutputComponents : u32;
	maxTessellationGenerationLevel : u32;
	maxTessellationPatchSize : u32;
	maxTessellationControlPerVertexInputComponents : u32;
	maxTessellationControlPerVertexOutputComponents : u32;
	maxTessellationControlPerPatchOutputComponents : u32;
	maxTessellationControlTotalOutputComponents : u32;
	maxTessellationEvaluationInputComponents : u32;
	maxTessellationEvaluationOutputComponents : u32;
	maxGeometryShaderInvocations : u32;
	maxGeometryInputComponents : u32;
	maxGeometryOutputComponents : u32;
	maxGeometryOutputVertices : u32;
	maxGeometryTotalOutputComponents : u32;
	maxFragmentInputComponents : u32;
	maxFragmentOutputAttachments : u32;
	maxFragmentDualSrcAttachments : u32;
	maxFragmentCombinedOutputResources : u32;
	maxComputeSharedMemorySize : u32;
	maxComputeWorkGroupCount : u32#3;
	maxComputeWorkGroupInvocations : u32;
	maxComputeWorkGroupSize : u32#3;
	subPixelPrecisionBits : u32;
	subTexelPrecisionBits : u32;
	mipmapPrecisionBits : u32;
	maxDrawIndexedIndexValue : u32;
	maxDrawIndirectCount : u32;
	maxSamplerLodBias : f32;
	maxSamplerAnisotropy : f32;
	maxViewports : u32;
	maxViewportDimensions : u32#2;
	viewportBoundsRange : f32#2;
	viewportSubPixelBits : u32;
	minMemoryMapAlignment : u64;
	minTexelBufferOffsetAlignment : u64;
	minUniformBufferOffsetAlignment : u64;
	minStorageBufferOffsetAlignment : u64;
	minTexelOffset : s32;
	maxTexelOffset : u32;
	minTexelGatherOffset : s32;
	maxTexelGatherOffset : u32;
	minInterpolationOffset : f32;
	maxInterpolationOffset : f32;
	subPixelInterpolationOffsetBits : u32;
	maxFramebufferWidth : u32;
	maxFramebufferHeight : u32;
	maxFramebufferLayers : u32;
	framebufferColorSampleCounts : u32;
	framebufferDepthSampleCounts : u32;
	framebufferStencilSampleCounts : u32;
	framebufferNoAttachmentsSampleCounts : u32;
	maxColorAttachments : u32;
	sampledImageColorSampleCounts : u32;
	sampledImageIntegerSampleCounts : u32;
	sampledImageDepthSampleCounts : u32;
	sampledImageStencilSampleCounts : u32;
	storageImageSampleCounts : u32;
	maxSampleMaskWords : u32;
	timestampComputeAndGraphics : u32;
	timestampPeriod : f32;
	maxClipDistances : u32;
	maxCullDistances : u32;
	maxCombinedClipAndCullDistances : u32;
	discreteQueuePriorities : u32;
	pointSizeRange : f32#2;
	lineWidthRange : f32#2;
	pointSizeGranularity : f32;
	lineWidthGranularity : f32;
	strictLines : u32;
	standardSampleLocations : u32;
	optimalBufferCopyOffsetAlignment : u64;
	optimalBufferCopyRowPitchAlignment : u64;
	nonCoherentAtomSize : u64;
};

VkPhysicalDeviceSparseProperties ::= struct
{
	residencyStandard2DBlockShape : u32;
	residencyStandard2DMultisampleBlockShape : u32;
	residencyStandard3DBlockShape : u32;
	residencyAlignedMipSize : u32;
	residencyNonResidentStrict : u32;
};

VkPhysicalDeviceProperties ::= struct
{
	apiVersion : u32;
	driverVersion : u32;
	vendorID : u32;
	deviceID : u32;
	deviceType : s32;
	deviceName : u8#256;
	pipelineCacheUUID : u8#16;
	limits : VkPhysicalDeviceLimits;
	sparseProperties : VkPhysicalDeviceSparseProperties;
};

VkMemoryType ::= struct
{
	propertyFlags : s32;
	heapIndex : u32;
};

VkMemoryHeap ::= struct
{
	size : u64;
	flags : u32;
};

VkPhysicalDeviceMemoryProperties ::= struct
{
	memoryTypeCount : u32;
	memoryTypes : VkMemoryType#32;
	memoryHeapCount : u32;
	memoryHeaps : VkMemoryHeap#32;
};

VkDeviceQueueCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	queueFamilyIndex : u32;
	queueCount : u32;
	pQueuePriorities : f32&;
};

VkPhysicalDeviceVulkan13Features ::= struct
{
	sType : s32;
	pNext : v0&;
	robustImageAccess : u32;
	inlineUniformBlock : u32;
	descriptorBindingInlineUniformBlockUpdateAfterBind : u32;
	pipelineCreationCacheControl : u32;
	privateData : u32;
	shaderDemoteToHelperInvocation : u32;
	shaderTerminateInvocation : u32;
	subgroupSizeControl : u32;
	computeFullSubgroups : u32;
	synchronization2 : u32;
	textureCompressionASTC_HDR : u32;
	shaderZeroInitializeWorkgroupMemory : u32;
	dynamicRendering : u32;
	shaderIntegerDotProduct : u32;
	maintenance4 : u32;
};

VkPhysicalDeviceVulkan12Features ::= struct
{
	sType : s32;
	pNext : v0&;
	samplerMirrorClampToEdge : u32;
	drawIndirectCount : u32;
	storageBuffer8BitAccess : u32;
	uniformAndStorageBuffer8BitAccess : u32;
	storagePushConstant8 : u32;
	shaderBufferInt64Atomics : u32;
	shaderSharedInt64Atomics : u32;
	shaderFloat16 : u32;
	shaderInt8 : u32;
	descriptorIndexing : u32;
	shaderInputAttachmentArrayDynamicIndexing : u32;
	shaderUniformTexelBufferArrayDynamicIndexing : u32;
	shaderStorageTexelBufferArrayDynamicIndexing : u32;
	shaderUniformBufferArrayNonUniformIndexing : u32;
	shaderSampledImageArrayNonUniformIndexing : u32;
	shaderStorageBufferArrayNonUniformIndexing : u32;
	shaderStorageImageArrayNonUniformIndexing : u32;
	shaderInputAttachmentArrayNonUniformIndexing : u32;
	shaderUniformTexelBufferArrayNonUniformIndexing : u32;
	shaderStorageTexelBufferArrayNonUniformIndexing : u32;
	descriptorBindingUniformBufferUpdateAfterBind : u32;
	descriptorBindingSampledImageUpdateAfterBind : u32;
	descriptorBindingStorageImageUpdateAfterBind : u32;
	descriptorBindingStorageBufferUpdateAfterBind : u32;
	descriptorBindingUniformTexelBufferUpdateAfterBind : u32;
	descriptorBindingStorageTexelBufferUpdateAfterBind : u32;
	descriptorBindingUpdateUnusedWhilePending : u32;
	descriptorBindingPartiallyBound : u32;
	descriptorBindingVariableDescriptorCount : u32;
	runtimeDescriptorArray : u32;
	samplerFilterMinmax : u32;
	scalarBlockLayout : u32;
	imagelessFramebuffer : u32;
	uniformBufferStandardLayout : u32;
	shaderSubgroupExtendedTypes : u32;
	separateDepthStencilLayouts : u32;
	hostQueryReset : u32;
	timelineSemaphore : u32;
	bufferDeviceAddress : u32;
	bufferDeviceAddressCaptureReplay : u32;
	bufferDeviceAddressMultiDevice : u32;
	vulkanMemoryModel : u32;
	vulkanMemoryModelDeviceScope : u32;
	vulkanMemoryModelAvailabilityVisibilityChains : u32;
	shaderOutputViewportIndex : u32;
	shaderOutputLayer : u32;
	subgroupBroadcastDynamicId : u32;
};

VkPhysicalDeviceFeatures ::= struct
{
	robustBufferAccess : u32;
	fullDrawIndexUint32 : u32;
	imageCubeArray : u32;
	independentBlend : u32;
	geometryShader : u32;
	tessellationShader : u32;
	sampleRateShading : u32;
	dualSrcBlend : u32;
	logicOp : u32;
	multiDrawIndirect : u32;
	drawIndirectFirstInstance : u32;
	depthClamp : u32;
	depthBiasClamp : u32;
	fillModeNonSolid : u32;
	depthBounds : u32;
	wideLines : u32;
	largePoints : u32;
	alphaToOne : u32;
	multiViewport : u32;
	samplerAnisotropy : u32;
	textureCompressionETC2 : u32;
	textureCompressionASTC_LDR : u32;
	textureCompressionBC : u32;
	occlusionQueryPrecise : u32;
	pipelineStatisticsQuery : u32;
	vertexPipelineStoresAndAtomics : u32;
	fragmentStoresAndAtomics : u32;
	shaderTessellationAndGeometryPointSize : u32;
	shaderImageGatherExtended : u32;
	shaderStorageImageExtendedFormats : u32;
	shaderStorageImageMultisample : u32;
	shaderStorageImageReadWithoutFormat : u32;
	shaderStorageImageWriteWithoutFormat : u32;
	shaderUniformBufferArrayDynamicIndexing : u32;
	shaderSampledImageArrayDynamicIndexing : u32;
	shaderStorageBufferArrayDynamicIndexing : u32;
	shaderStorageImageArrayDynamicIndexing : u32;
	shaderClipDistance : u32;
	shaderCullDistance : u32;
	shaderFloat64 : u32;
	shaderInt64 : u32;
	shaderInt16 : u32;
	shaderResourceResidency : u32;
	shaderResourceMinLod : u32;
	sparseBinding : u32;
	sparseResidencyBuffer : u32;
	sparseResidencyImage2D : u32;
	sparseResidencyImage3D : u32;
	sparseResidency2Samples : u32;
	sparseResidency4Samples : u32;
	sparseResidency8Samples : u32;
	sparseResidency16Samples : u32;
	sparseResidencyAliased : u32;
	variableMultisampleRate : u32;
	inheritedQueries : u32;
};

VkPhysicalDeviceFeatures2 ::= struct
{
	sType : s32;
	pNext : v0&;
	features : VkPhysicalDeviceFeatures;
};

VkDeviceCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	queueCreateInfoCount : u32;
	pQueueCreateInfos : VkDeviceQueueCreateInfo&;
	enabledLayerCount : u32;
	ppEnabledLayerNames : u8&&;
	enabledExtensionCount : u32;
	ppEnabledExtensionNames : u8&&;
	pEnabledFeatures : VkPhysicalDeviceFeatures&;
};

VkExtent2D ::= struct
{
	width : u32;
	height : u32;
};

VkExtent3D ::= struct
{
	width : u32;
	height : u32;
	depth : u32;
};

VkQueueFamilyProperties ::= struct
{
	queueFlags : u32;
	queueCount : u32;
	timestampValidBits : u32;
	minImageTransferGranularity : VkExtent3D;
};

VkSurfaceCapabilitiesKHR ::= struct
{
	minImageCount : u32;
	maxImageCount : u32;
	currentExtent : VkExtent2D;
	minImageExtent : VkExtent2D;
	maxImageExtent : VkExtent2D;
	maxImageArrayLayers : u32;
	supportedTransforms : s32;
	currentTransform : s32;
	supportedCompositeAlpha : s32;
	supportedUsageFlags : s32;
};

VkSwapchainCreateInfoKHR ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	surface : u64;
	minImageCount : u32;
	imageFormat : s32;
	imageColorSpace : s32;
	imageExtent : VkExtent2D;
	imageArrayLayers : u32;
	imageUsage : s32;
	imageSharingMode : s32;
	queueFamilyIndexCount : u32;
	pQueueFamilyIndices : u32&;
	preTransform : s32;
	compositeAlpha : s32;
	presentMode : s32;
	clipped : u32;
	oldSwapchain : u64;
};

VkCommandPoolCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	queueFamilyIndex : u32;
};

VkCommandBufferAllocateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	commandPool : u64;
	level : s32;
	commandBufferCount : u32;
};

VkFenceCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
};

VkSemaphoreCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
};

VkDescriptorSetLayoutBinding ::= struct
{
	binding : u32;
	descriptorType : s32;
	descriptorCount : u32;
	stageFlags : s32;
	pImmutableSamplers : u64&;
};

VkDescriptorSetLayoutBindingFlagsCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	bindingCount : u32;
	pBindingFlags : s32&;
};

VkDescriptorSetLayoutCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	bindingCount : u32;
	pBindings : VkDescriptorSetLayoutBinding&;
};

VkPushConstantRange ::= struct
{
	stageFlags : s32;
	offset : u32;
	size : u32;
};

VkPipelineLayoutCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	setLayoutCount : u32;
	pSetLayouts : u64&;
	pushConstantRangeCount : u32;
	pPushConstantRanges : VkPushConstantRange&;
};

VkImageCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	imageType : s32;
	format : s32;
	extent : VkExtent3D;
	mipLevels : u32;
	arrayLayers : u32;
	samples : s32;
	tiling : s32;
	usage : s32;
	sharingMode : s32;
	queueFamilyIndexCount : u32;
	pQueueFamilyIndices : u32&;
	initialLayout : s32;
};

VkBufferCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	size : u64;
	usage : s32;
	sharingMode : s32;
	queueFamilyIndexCount : u32;
	pQueueFamilyIndices : u32&;
};

VkBufferDeviceAddressInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	buffer : u64;
};

VkShaderModuleCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	codeSize : u64;
	pCode : u32&; // ok vulkan thinks its really clever to use u32s here so i will respect it, even though i've decided it was a stupid decision.
};

VkPipelineShaderStageCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	stage : s32;
	module : u64;
	pName : u8&;
	pSpecializationInfo : v0&;
};

VkComputePipelineCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	stage : VkPipelineShaderStageCreateInfo;
	layout : u64;
	basePipelineHandle : u64;
	basePipelineIndex : s32;
};

VkPipelineVertexInputStateCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	vertexBindingDescriptionCount : u32;
	pVertexBindingDescriptions : v0&;
	vertexAttributeDescriptionCount : u32;
	pVertexAttributeDescriptions : v0&;
};

VkPipelineInputAssemblyStateCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	topology : s32;
	primitiveRestartEnable : u32;
};

VkPipelineTessellationStateCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	patchControlPoints : u32;
};

VkPipelineViewportStateCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	viewportCount : u32;
	pViewports : v0&;
	scissorCount : u32;
	pScissors : v0&;
};

VkPipelineRasterizationStateCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	depthClampEnable : u32;
	rasterizerDiscardEnable : u32;
	polygonMode : s32;
	cullMode : s32;
	frontFace : s32;
	depthBiasEnable : u32;
	depthBiasConstantFactor : f32;
	depthBiasClamp : f32;
	depthBiasSlopeFactor : f32;
	lineWidth : f32;
};

VkPipelineMultisampleStateCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	rasterizationSamples : s32;
	sampleShadingEnable : u32;
	minSampleShading : f32;
	pSampleMask : v0&;
	alphaToCoverageEnable : u32;
	alphaToOneEnable : u32;
};

VkStencilOpState ::= struct
{
	failOp : s32;
	passOp : s32;
	depthFailOp : s32;
	compareOp : s32;
	compareMask : u32;
	writeMask : u32;
	reference : u32;
};

VkPipelineDepthStencilStateCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	depthTestEnable : u32;
	depthWriteEnable : u32;
	depthCompareOp : s32;
	depthBoundsTestEnable : u32;
	stencilTestEnable : u32;
	front : VkStencilOpState;
	back : VkStencilOpState;
	minDepthBounds : f32;
	maxDepthBounds : f32;
};

VkPipelineColorBlendAttachmentState ::= struct
{
	blendEnable : u32;
	srcColorBlendFactor : s32;
	dstColorBlendFactor : s32;
	colorBlendOp : s32;
	srcAlphaBlendFactor : s32;
	dstAlphaBlendFactor : s32;
	alphaBlendOp : s32;
	colorWriteMask : s32;
};

VkPipelineColorBlendStateCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	logicOpEnable : u32;
	logicOp : s32;
	attachmentCount : u32;
	pAttachments : VkPipelineColorBlendAttachmentState&;
	blendConstants : f32 mut#4;
};

VkPipelineRenderingCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	viewMask : u32;
	colorAttachmentCount : u32;
	pColorAttachmentFormats : s32&;
	depthAttachmentFormat : s32;
	stencilAttachmentFormat : s32;
};

VkPipelineDynamicStateCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	dynamicStateCount : u32;
	pDynamicStates : s32&;
};

VkGraphicsPipelineCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	stageCount : u32;
	pStages : VkPipelineShaderStageCreateInfo&;
	pVertexInputState : VkPipelineVertexInputStateCreateInfo&;
	pInputAssemblyState : VkPipelineInputAssemblyStateCreateInfo&;
	pTessellationState : VkPipelineTessellationStateCreateInfo&;
	pViewportState : VkPipelineViewportStateCreateInfo&;
	pRasterizationState : VkPipelineRasterizationStateCreateInfo&;
	pMultisampleState : VkPipelineMultisampleStateCreateInfo&;
	pDepthStencilState : VkPipelineDepthStencilStateCreateInfo&;
	pColorBlendState : VkPipelineColorBlendStateCreateInfo&;
	pDynamicState : VkPipelineDynamicStateCreateInfo&;
	layout : u64;
	renderPass : u64;
	subpass : u32;
	basePipelineHandle : u64;
	basePipelineIndex : s32;
};

VkCommandBufferBeginInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	pInheritanceInfo : v0&;
};

VkSubmitInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	waitSemaphoreCount : u32;
	pWaitSemaphores : u64&;
	pWaitDstStageMask : s32&;
	commandBufferCount : u32;
	pCommandBuffers : u64&;
	signalSemaphoreCount : u32;
	pSignalSemaphores : u64&;
};

VkMemoryBarrier ::= struct
{
	sType : s32;
	pNext : v0&;
	srcAccessMask : s32;
	dstAccessMask : s32;
};

VkBufferMemoryBarrier ::= struct
{
	sType : s32;
	pNext : v0&;
	srcAccessMask : s32;
	dstAccessMask : s32;
	srcQueueFamilyIndex : u32;
	dstQueueFamilyIndex : u32;
	buffer : u64;
	offset : u64;
	size : u64;
};

VkImageSubresourceRange ::= struct
{
	aspectMask : s32;
	baseMipLevel : u32;
	levelCount : u32;
	baseArrayLayer : u32;
	layerCount : u32;
};

VkImageMemoryBarrier ::= struct
{
	sType : s32;
	pNext : v0&;
	srcAccessMask : s32;
	dstAccessMask : s32;
	oldLayout : s32;
	newLayout : s32;
	srcQueueFamilyIndex : u32;
	dstQueueFamilyIndex : u32;
	image : u64;
	subresourceRange : VkImageSubresourceRange;
};

VkMemoryRequirements ::= struct
{
	size : u64;
	align : u64;
	memoryTypeBits : u32;
};

VkOffset2D ::= struct
{
	x : s32;
	y : s32;
};

VkRect2D ::= struct
{
	offset : VkOffset2D;
	extent : VkExtent2D;
};

VkClearColorValue ::= struct
{
	float32 : vec4;
};

// note this is meant to be a union of VkClearColorValue and VkClearDepthStencilValue
// well we dont support that. VkClearColorValue is the larger of the two so it will just be that.
VkClearValue ::= struct
{
	color : VkClearColorValue;
};

VkRenderingAttachmentInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	imageView : u64;
	imageLayout : s32;
	resolveMode : s32;
	resolveImageView : u64;
	resolveImageLayout : s32;
	loadOp : s32;
	storeOp : s32;
	clearValue : VkClearValue;
};

VkRenderingInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	renderArea : VkRect2D;
	layerCount : u32;
	viewMask : u32;
	colorAttachmentCount : u32;
	pColorAttachments : VkRenderingAttachmentInfo&;
	pDepthAttachment : VkRenderingAttachmentInfo&;
	pStencilAttachment : VkRenderingAttachmentInfo&;
};

VkComponentMapping ::= struct
{
	r : s32;
	g : s32;
	b : s32;
	a : s32;
};

VkImageViewCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	image : u64;
	viewType : s32;
	format : s32;
	components : VkComponentMapping;
	subresourceRange : VkImageSubresourceRange;
};

VkViewport ::= struct
{
	x : f32;
	y : f32;
	width : f32;
	height : f32;
	minDepth : f32;
	maxDepth : f32;
};

VkImageSubresourceLayers ::= struct
{
	aspectMask : s32;
	mipLevel : u32;
	baseArrayLayer : u32;
	layerCount : u32;
};

VkOffset3D ::= struct
{
	x : s32;
	y : s32;
	z : s32;
};

VkImageBlit ::= struct
{
	srcSubresource : VkImageSubresourceLayers;
	srcOffsets : VkOffset3D mut#2;
	dstSubresource : VkImageSubresourceLayers;
	dstOffsets : VkOffset3D mut#2;
};

VkPresentInfoKHR ::= struct
{
	sType : s32;
	pNext : v0&;
	waitSemaphoreCount : u32;
	pWaitSemaphores : u64&;
	swapchainCount : u32;
	pSwapchains : u64&;
	pImageIndices : u32&;
	pResults : s32 mut&;
};

VkDescriptorPoolSize ::= struct
{
	type : s32;
	descriptorCount : u32;
};

VkDescriptorPoolCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	maxSets : u32;
	poolSizeCount : u32;
	pPoolSizes : VkDescriptorPoolSize&;
};

VkDescriptorSetVariableDescriptorCountAllocateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	descriptorSetCount : u32;
	pDescriptorCounts : u32&;
};

VkDescriptorSetAllocateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	descriptorPool : u64;
	descriptorSetCount : u32;
	pSetLayouts : u64&;
};

VkDescriptorImageInfo ::= struct
{
	sampler : u64;
	imageView : u64;
	imageLayout : s32;
};

VkDescriptorBufferInfo ::= struct
{
	buffer : u64;
	offset : u64;
	range : u64;
};

VkWriteDescriptorSet ::= struct
{
	sType : s32;
	pNext : v0&;
	dstSet : u64;
	dstBinding : u32;
	dstArrayElement : u32;
	descriptorCount : u32;
	descriptorType : s32;
	pImageInfo : VkDescriptorImageInfo&;
	pBufferInfo : VkDescriptorBufferInfo&;
	pTexelBufferView : s32&;
};

VkCopyDescriptorSet ::= struct
{
	sType : s32;
	pNext : v0&;
	srcSet : u64;
	srcBinding : u32;
	srcArrayElement : u32;
	dstSet : u64;
	dstBinding : u32;
	dstArrayElement : u32;
	descriptorCount : u32;
};

VkBufferCopy ::= struct
{
	srcOffset : u64;
	dstOffset : u64;
	size : u64;
};

VkBufferImageCopy ::= struct
{
	bufferOffset : u64;
	bufferRowLength : u32;
	bufferImageHeight : u32;
	imageSubresource : VkImageSubresourceLayers;
	imageOffset : VkOffset3D;
	imageExtent : VkExtent3D;
};

VkSamplerCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	magFilter : s32;
	minFilter : s32;
	mipmapMode : s32;
	addressModeU : s32;
	addressModeV : s32;
	addressModeW : s32;
	mipLodBias : f32;
	anisotropyEnable : u32;
	maxAnisotropy : f32;
	compareEnable : u32;
	compareOp : s32;
	minLod : f32;
	maxLod : f32;
	borderColor : s32;
	unnormalizedCoordinates : u32;
};

vk_functions_t ::= struct
{
	get_instance_proc_addr : func(instance : u64, funcname : u8&) -> u64 weak;
	create_instance : func(pCreateInfo : VkInstanceCreateInfo&, pAllocator : VkAllocationCallbacks&, pInstance : u64 mut&) -> s32;
	destroy_instance : func(instance : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	allocate_memory : func(device : u64, pAllocateInfo : VkMemoryAllocateInfo&, pAllocator : VkAllocationCallbacks&, pMemory : u64 mut&) -> s32;
	free_memory : func(device : u64, memory : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	bind_buffer_memory : func(device : u64, buffer : u64, memory : u64, memoryOffset : u64) -> s32;
	bind_image_memory : func(device : u64, image : u64, memory : u64, memoryOffset : u64) -> s32;

	if static(__is_windows)
	{
		create_win32_surface_khr : func(instance : u64, pCreateInfo : VkWin32SurfaceCreateInfoKHR&, pAllocator : VkAllocationCallbacks&, surface : u64 mut&) -> s32;
	}
	destroy_surface_khr : func(instance : u64, surface : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	create_swapchain_khr : func(device : u64, pCreateInfo : VkSwapchainCreateInfoKHR&, pAllocator : VkAllocationCallbacks&, pSwapchain : u64 mut&) -> s32;
	destroy_swapchain_khr : func(device : u64, swapchain : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	get_swapchain_images_khr : func(device : u64, swapchain : u64, pSwapchainImageCount : u32 mut&, pSwapchainImages : u64&) -> s32;
	acquire_next_image_khr : func(device : u64, swapchain : u64, timeout : u64, semaphore : u64, fence : u64, pImageIndex : u32 mut&) -> s32;

	queue_present_khr : func(queue : u64, pPresentInfo : VkPresentInfoKHR&) -> s32;

	create_image : func(device : u64, pCreateInfo : VkImageCreateInfo&, pAllocator : VkAllocationCallbacks&, pImage : u64 mut&) -> s32;
	destroy_image : func(device : u64, image : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	create_image_view : func(device : u64, pCreateInfo : VkImageViewCreateInfo&, pAllocator : VkAllocationCallbacks&, pView : u64 mut&) -> s32;
	destroy_image_view : func(device : u64, imageView : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	create_sampler : func(device : u64, pCreateInfo : VkSamplerCreateInfo&, pAllocator : VkAllocationCallbacks&, pSampler : u64 mut&) -> s32;
	destroy_sampler : func(device : u64, sampler : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	enumerate_physical_devices : func(instance : u64, pPhysicalDeviceCount : u32 mut&, pPhysicalDevices : u64 mut&) -> s32;
	get_physical_device_properties : func(physicalDevice : u64, pProperties : VkPhysicalDeviceProperties mut&) -> v0;
	get_physical_device_memory_properties : func(physicalDevice : u64, pMemoryProperties : VkPhysicalDeviceMemoryProperties mut&) -> v0;
	get_physical_device_queue_family_properties : func(physicalDevice : u64, pQueueFamilyPropertyCount : u32 mut&, pQueueFamilyProperties : VkQueueFamilyProperties mut&) -> v0;
	get_physical_device_surface_capabilities_khr : func(physicalDevice : u64, surface : u64, pSurfaceCapabilities : VkSurfaceCapabilitiesKHR mut&) -> s32;

	create_device : func(physicalDevice : u64, pCreateInfo : VkDeviceCreateInfo&, pAllocator : VkAllocationCallbacks&, pDevice : u64 mut&) -> s32;
	destroy_device : func(device : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	get_device_queue : func(device : u64, queueFamilyIndex : u32, queueIndex : u32, pQueue : u64 mut&) -> v0;

	create_command_pool : func(device : u64, pCreateInfo : VkCommandPoolCreateInfo&, pAllocator : VkAllocationCallbacks&, pCommandPool : u64 mut&) -> s32;
	destroy_command_pool : func(device : u64, commandPool : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	allocate_command_buffers : func(device : u64, pAllocateInfo : VkCommandBufferAllocateInfo&, pCommandBuffers : u64 mut&) -> s32;

	create_fence : func(device : u64, pCreateInfo : VkFenceCreateInfo&, pAllocator : VkAllocationCallbacks&, pFence : u64 mut&) -> s32;
	destroy_fence : func(device : u64, fence : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	create_semaphore : func(device : u64, pCreateInfo : VkSemaphoreCreateInfo&, pAllocator : VkAllocationCallbacks&, pSemaphore : u64 mut&) -> s32;
	destroy_semaphore : func(device : u64, semaphore : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	create_descriptor_set_layout : func(device : u64, pCreateInfo : VkDescriptorSetLayoutCreateInfo&, pAllocator : VkAllocationCallbacks&, pSetLayout : u64 mut&) -> s32;
	destroy_descriptor_set_layout : func(device : u64, descriptorSetLayout : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	create_pipeline_layout : func(device : u64, pCreateInfo : VkPipelineLayoutCreateInfo&, pAllocator : VkAllocationCallbacks&, pPipelineLayout : u64 mut&) -> s32;
	destroy_pipeline_layout : func(device : u64, pipelineLayout : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	create_descriptor_pool : func(device : u64, pCreateInfo : VkDescriptorPoolCreateInfo&, pAllocator : VkAllocationCallbacks&, pDescriptorPool : u64 mut&) -> s32;
	destroy_descriptor_pool : func(device : u64, descriptorPool : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	allocate_descriptor_sets : func(device : u64, pAllocateInfo : VkDescriptorSetAllocateInfo&, pDescriptorSets : u64 mut&) -> s32;
	update_descriptor_sets : func(device : u64, descriptorWriteCount : u32, pDescriptorWrites : VkWriteDescriptorSet&, descriptorCopyCount : u32, pDescriptorCopies : VkCopyDescriptorSet&) -> v0;

	create_buffer : func(device : u64, pCreateInfo : VkBufferCreateInfo&, pAllocator : VkAllocationCallbacks&, pBuffer : u64 mut&) -> s32;
	destroy_buffer : func(device : u64, buffer : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	get_buffer_device_address : func(device : u64, pInfo : VkBufferDeviceAddressInfo&) -> u64;

	create_shader_module : func(device : u64, pCreateInfo : VkShaderModuleCreateInfo&, pAllocator : VkAllocationCallbacks&, pShaderModule : u64 mut&) -> s32;
	destroy_shader_module : func(device : u64, shaderModule : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	create_compute_pipelines : func(device : u64, pipelineCache : u64, createInfoCount : u32, pCreateInfos : VkComputePipelineCreateInfo&, pAllocator : VkAllocationCallbacks&, pPipelines : u64 mut&) -> s32;
	create_graphics_pipelines : func(device : u64, pipelineCache : u64, createInfoCount : u32, pCreateInfos : VkGraphicsPipelineCreateInfo&, pAllocator : VkAllocationCallbacks&, pPipelines : u64 mut&) -> s32;
	destroy_pipeline : func(device : u64, pipeline : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	begin_command_buffer : func(commandBuffer : u64, pBeginInfo : VkCommandBufferBeginInfo&) -> s32;
	end_command_buffer : func(commandBuffer : u64) -> s32;
	reset_command_buffer : func(commandBuffer : u64, flags : s32) -> s32;

	get_image_memory_requirements : func(device : u64, image : u64, pMemoryRequirements : VkMemoryRequirements mut&) -> v0;
	get_buffer_memory_requirements : func(device : u64, buffer : u64, pMemoryRequirements : VkMemoryRequirements mut&) -> v0;
	map_memory : func(device : u64, memory : u64, offset : u64, size : u64, flags : s32, ppData : v0 mut&& weak) -> s32;

	queue_submit : func(queue : u64, submitCount : u32, pSubmits : VkSubmitInfo&, fence : u64) -> s32;
	wait_for_fences : func(device : u64, fenceCount : u32, pFences : u64&, waitAll : u32, timeout : u64) -> s32;
	reset_fences : func(device : u64, fenceCount : u32, pFences : u64&) -> s32;

	cmd_bind_pipeline : func(commandBuffer : u64, pipelineBindPoint : s32, pipeline : u64) -> v0;
	cmd_bind_descriptor_sets : func(commandBuffer : u64, pipelineBindPoint : s32, layout : u64, firstSet : u32, descriptorSetCount : u32, pDescriptorSets : u64&, dynamicOffsetCount : u32, pDynamicOffsets : u32&) -> v0;
	cmd_dispatch : func(commandBuffer : u64, groupCountX : u32, groupCountY : u32, groupCountZ : u32) -> v0;
	cmd_pipeline_barrier : func(commandBuffer : u64, srcStageMask : s32, dstStageMask : s32, dependencyFlags : s32, memoryBarrierCount : u32, pMemoryBarriers : VkMemoryBarrier&, bufferMemoryBarrierCount : u32, pBufferMemoryBarriers : VkBufferMemoryBarrier&, imageMemoryBarrierCount : u32, pImageMemoryBarriers : VkImageMemoryBarrier&) -> v0;
	cmd_begin_rendering : func(commandBuffer : u64, pRenderingInfo : VkRenderingInfo&) -> v0;
	cmd_end_rendering : func(commandBuffer : u64) -> v0;
	cmd_set_viewport : func(commandBuffer : u64, firstViewport : u32, viewportCount : u32, pViewports : VkViewport&) -> v0;
	cmd_set_scissor : func(commandBuffer : u64, firstScissor : u32, scissorCount : u32, pScissors : VkRect2D&) -> v0;
	cmd_blit_image : func(commandBuffer : u64, srcImage : u64, srcImageLayout : s32, dstImage : u64, dstImageLayout : s32, regionCount : u32, pRegions : VkImageBlit&, filter : s32) -> v0;
	cmd_bind_index_buffer : func(commandBuffer : u64, buffer : u64, offset : u64, indexType : s32) -> v0;
	cmd_draw : func(commandBuffer : u64, vertexCount : u32, instanceCount : u32, firstVertex : u32, firstInstance : u32) -> v0;
	cmd_draw_indexed : func(commandBuffer : u64, indexCount : u32, instanceCount : u32, firstIndex : u32, vertexOffset : s32, firstInstance : u32) -> v0;
	cmd_draw_indirect_count : func(commandBuffer : u64, buffer : u64, offset : u64, countBuffer : u64, countBufferOffset : u64, maxDrawCount : u32, stride : u32) -> v0;
	cmd_draw_indexed_indirect_count : func(commandBuffer : u64, buffer : u64, offset : u64, countBuffer : u64, countBufferOffset : u64, maxDrawCount : u32, stride : u32) -> v0;
	cmd_copy_buffer : func(commandBuffer : u64, srcBuffer : u64, dstBuffer : u64, regionCount : u32, pRegions : VkBufferCopy&) -> v0;
	cmd_copy_buffer_to_image : func(commandBuffer : u64, srcBuffer : u64, dstImage : u64, dstImageLayout : s32, regionCount : u32, pRegions : VkBufferImageCopy&) -> v0;

	device_wait_idle : func(device : u64) -> v0;
};

vk : vk_functions_t mut;

vulkan_driver : u64 weak mut := -1;
vulkan_driver_initialised : bool mut := false;

load_vk_driver_fn ::= func(funcname : u8&, module : u64) -> u64 weak
{
	addr ::= GetProcAddress(module, funcname);
	if(addr == null)
	{
		puts("failed to load driver function ");
		puts(funcname);
		putchar(10);
		__debugbreak();
	}
	return addr;
};

load_vk_fn ::= func(funcname : u8&, instance : u64) -> u64 weak
{
	addr ::= vk.get_instance_proc_addr(instance, funcname);
	if(addr == null)
	{
		puts("failed to load function ");
		puts(funcname);
		putchar(10);
		__debugbreak();
	}
	return addr;
};

donestr ::= "done.\n";

vulkan_init ::= func() -> v0
{
	initialised_driver : bool mut := false;
	if(!vulkan_driver_initialised)
	{
		vulkan_driver = LoadLibraryA("vulkan-1.dll");
		if(vulkan_driver == 0)
		{
			__debugbreak();
		}
		puts("loading from vulkan driver...");
		vulkan_driver_initialised = true;
		initialised_driver = true;
	}
	defer puts(donestr);

	vk.create_instance = load_vk_driver_fn("vkCreateInstance", vulkan_driver);
	vk.destroy_instance = load_vk_driver_fn("vkDestroyInstance", vulkan_driver);
	vk.get_instance_proc_addr = load_vk_driver_fn("vkGetInstanceProcAddr", vulkan_driver);
};

vulkan_load_functions ::= func(instance : u64) -> v0
{
	vk.allocate_memory = load_vk_fn("vkAllocateMemory", instance);
	vk.free_memory = load_vk_fn("vkFreeMemory", instance);

	vk.bind_buffer_memory = load_vk_fn("vkBindBufferMemory", instance);
	vk.bind_image_memory = load_vk_fn("vkBindImageMemory", instance);

	if static(__is_windows)
	{
		vk.create_win32_surface_khr = load_vk_fn("vkCreateWin32SurfaceKHR", instance);
	}
	vk.destroy_surface_khr = load_vk_fn("vkDestroySurfaceKHR", instance);
	vk.create_swapchain_khr = load_vk_fn("vkCreateSwapchainKHR", instance);
	vk.destroy_swapchain_khr = load_vk_fn("vkDestroySwapchainKHR", instance);
	vk.get_swapchain_images_khr = load_vk_fn("vkGetSwapchainImagesKHR", instance);
	vk.acquire_next_image_khr = load_vk_fn("vkAcquireNextImageKHR", instance);

	vk.queue_present_khr = load_vk_fn("vkQueuePresentKHR", instance);

	vk.create_image = load_vk_fn("vkCreateImage", instance);
	vk.destroy_image = load_vk_fn("vkDestroyImage", instance);
	vk.create_image_view = load_vk_fn("vkCreateImageView", instance);
	vk.destroy_image_view = load_vk_fn("vkDestroyImageView", instance);
	vk.create_sampler = load_vk_fn("vkCreateSampler", instance);
	vk.destroy_sampler = load_vk_fn("vkDestroySampler", instance);

	vk.enumerate_physical_devices = load_vk_fn("vkEnumeratePhysicalDevices", instance);
	vk.get_physical_device_properties = load_vk_fn("vkGetPhysicalDeviceProperties", instance);
	vk.get_physical_device_memory_properties = load_vk_fn("vkGetPhysicalDeviceMemoryProperties", instance);
	vk.get_physical_device_queue_family_properties = load_vk_fn("vkGetPhysicalDeviceQueueFamilyProperties", instance);
	vk.get_physical_device_surface_capabilities_khr = load_vk_fn("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", instance);

	vk.create_device = load_vk_fn("vkCreateDevice", instance);
	vk.destroy_device = load_vk_fn("vkDestroyDevice", instance);
	vk.get_device_queue = load_vk_fn("vkGetDeviceQueue", instance);

	vk.create_command_pool = load_vk_fn("vkCreateCommandPool", instance);
	vk.destroy_command_pool = load_vk_fn("vkDestroyCommandPool", instance);
	vk.allocate_command_buffers = load_vk_fn("vkAllocateCommandBuffers", instance);

	vk.create_fence = load_vk_fn("vkCreateFence", instance);
	vk.destroy_fence = load_vk_fn("vkDestroyFence", instance);

	vk.create_semaphore = load_vk_fn("vkCreateSemaphore", instance);
	vk.destroy_semaphore = load_vk_fn("vkDestroySemaphore", instance);

	vk.create_descriptor_set_layout = load_vk_fn("vkCreateDescriptorSetLayout", instance);
	vk.destroy_descriptor_set_layout = load_vk_fn("vkDestroyDescriptorSetLayout", instance);
	vk.create_pipeline_layout = load_vk_fn("vkCreatePipelineLayout", instance);
	vk.destroy_pipeline_layout = load_vk_fn("vkDestroyPipelineLayout", instance);

	vk.create_descriptor_pool = load_vk_fn("vkCreateDescriptorPool", instance);
	vk.destroy_descriptor_pool = load_vk_fn("vkDestroyDescriptorPool", instance);

	vk.allocate_descriptor_sets = load_vk_fn("vkAllocateDescriptorSets", instance);
	vk.update_descriptor_sets = load_vk_fn("vkUpdateDescriptorSets", instance);

	vk.create_buffer = load_vk_fn("vkCreateBuffer", instance);
	vk.destroy_buffer = load_vk_fn("vkDestroyBuffer", instance);

	vk.get_buffer_device_address = load_vk_fn("vkGetBufferDeviceAddress", instance);

	vk.create_shader_module = load_vk_fn("vkCreateShaderModule", instance);
	vk.destroy_shader_module = load_vk_fn("vkDestroyShaderModule", instance);

	vk.create_compute_pipelines = load_vk_fn("vkCreateComputePipelines", instance);
	vk.create_graphics_pipelines = load_vk_fn("vkCreateGraphicsPipelines", instance);
	vk.destroy_pipeline = load_vk_fn("vkDestroyPipeline", instance);

	vk.begin_command_buffer = load_vk_fn("vkBeginCommandBuffer", instance);
	vk.end_command_buffer = load_vk_fn("vkEndCommandBuffer", instance);
	vk.reset_command_buffer = load_vk_fn("vkResetCommandBuffer", instance);

	vk.get_image_memory_requirements = load_vk_fn("vkGetImageMemoryRequirements", instance);
	vk.get_buffer_memory_requirements = load_vk_fn("vkGetBufferMemoryRequirements", instance);
	vk.map_memory = load_vk_fn("vkMapMemory", instance);

	vk.queue_submit = load_vk_fn("vkQueueSubmit", instance);
	vk.wait_for_fences = load_vk_fn("vkWaitForFences", instance);
	vk.reset_fences = load_vk_fn("vkResetFences", instance);

	vk.cmd_bind_pipeline = load_vk_fn("vkCmdBindPipeline", instance);
	vk.cmd_bind_descriptor_sets = load_vk_fn("vkCmdBindDescriptorSets", instance);
	vk.cmd_dispatch = load_vk_fn("vkCmdDispatch", instance);
	vk.cmd_pipeline_barrier = load_vk_fn("vkCmdPipelineBarrier", instance);
	vk.cmd_begin_rendering = load_vk_fn("vkCmdBeginRendering", instance);
	vk.cmd_end_rendering = load_vk_fn("vkCmdEndRendering", instance);
	vk.cmd_set_viewport = load_vk_fn("vkCmdSetViewport", instance);
	vk.cmd_set_scissor = load_vk_fn("vkCmdSetScissor", instance);
	vk.cmd_blit_image = load_vk_fn("vkCmdBlitImage", instance);
	vk.cmd_bind_index_buffer = load_vk_fn("vkCmdBindIndexBuffer", instance);
	vk.cmd_draw = load_vk_fn("vkCmdDraw", instance);
	vk.cmd_draw_indexed = load_vk_fn("vkCmdDrawIndexed", instance);
	vk.cmd_draw_indirect_count = load_vk_fn("vkCmdDrawIndirectCount", instance);
	vk.cmd_draw_indexed_indirect_count = load_vk_fn("vkCmdDrawIndexedIndirectCount", instance);
	vk.cmd_copy_buffer = load_vk_fn("vkCmdCopyBuffer", instance);
	vk.cmd_copy_buffer_to_image = load_vk_fn("vkCmdCopyBufferToImage", instance);

	vk.device_wait_idle = load_vk_fn("vkDeviceWaitIdle", instance);
};

vulkan_term ::= func() -> v0
{
	// let go of the vulkan driver.
	if(vulkan_driver_initialised)
	{
		FreeLibrary(vulkan_driver);
		vulkan_driver_initialised = false;
	}
};

VK_MAKE_API_VERSION ::= func(variant : u32 weak, major : u32 weak, minor : u32 weak, patch : u32 weak) -> u32
{
	return (variant * 536870912) | (major * 4194304) | (minor * 4096) | patch;
};

VkResult ::= enum
{
	.VK_SUCCESS := 0;
	.VK_NOT_READY := 1;
	.VK_TIMEOUT := 2;
	.VK_EVENT_SET := 3;
	.VK_EVENT_RESET := 4;
	.VK_INCOMPLETE := 5;
	.VK_ERROR_OUT_OF_HOST_MEMORY := -1;
	.VK_ERROR_OUT_OF_DEVICE_MEMORY := -2;
	.VK_ERROR_INITIALIZATION_FAILED := -3;
	.VK_ERROR_DEVICE_LOST := -4;
	.VK_ERROR_MEMORY_MAP_FAILED := -5;
	.VK_ERROR_LAYER_NOT_PRESENT := -6;
	.VK_ERROR_EXTENSION_NOT_PRESENT := -7;
	.VK_ERROR_FEATURE_NOT_PRESENT := -8;
	.VK_ERROR_INCOMPATIBLE_DRIVER := -9;
	.VK_ERROR_TOO_MANY_OBJECTS := -10;
	.VK_ERROR_FORMAT_NOT_SUPPORTED := -11;
	.VK_ERROR_FRAGMENTED_POOL := -12;
	.VK_ERROR_UNKNOWN := -13;
	.VK_ERROR_OUT_OF_POOL_MEMORY := -1000069000;
// Provided by VK_VERSION_1_1
	.VK_ERROR_INVALID_EXTERNAL_HANDLE := -1000072003;
// Provided by VK_VERSION_1_2
	.VK_ERROR_FRAGMENTATION := -1000161000;
// Provided by VK_VERSION_1_2
	.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS := -1000257000;
// Provided by VK_VERSION_1_3
	.VK_PIPELINE_COMPILE_REQUIRED := 1000297000;
// Provided by VK_VERSION_1_4
	.VK_ERROR_NOT_PERMITTED := -1000174001;
// Provided by VK_KHR_surface
	.VK_ERROR_SURFACE_LOST_KHR := -1000000000;
// Provided by VK_KHR_surface
	.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR := -1000000001;
// Provided by VK_KHR_swapchain
	.VK_SUBOPTIMAL_KHR := 1000001003;
// Provided by VK_KHR_swapchain
	.VK_ERROR_OUT_OF_DATE_KHR := -1000001004;
// Provided by VK_KHR_display_swapchain
	.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR := -1000003001;
// Provided by VK_EXT_debug_report
	.VK_ERROR_VALIDATION_FAILED_EXT := -1000011001;
// Provided by VK_NV_glsl_shader
	.VK_ERROR_INVALID_SHADER_NV := -1000012000;
// Provided by VK_KHR_video_queue
	.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR := -1000023000;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR := -1000023001;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR := -1000023002;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR := -1000023003;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR := -1000023004;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR := -1000023005;
// Provided by VK_EXT_image_drm_format_modifier
	.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT := -1000158000;
// Provided by VK_EXT_full_screen_exclusive
	.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT := -1000255000;
// Provided by VK_KHR_deferred_host_operations
	.VK_THREAD_IDLE_KHR := 1000268000;
// Provided by VK_KHR_deferred_host_operations
	.VK_THREAD_DONE_KHR := 1000268001;
// Provided by VK_KHR_deferred_host_operations
	.VK_OPERATION_DEFERRED_KHR := 1000268002;
// Provided by VK_KHR_deferred_host_operations
	.VK_OPERATION_NOT_DEFERRED_KHR := 1000268003;
// Provided by VK_KHR_video_encode_queue
	.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR := -1000299000;
// Provided by VK_EXT_image_compression_control
	.VK_ERROR_COMPRESSION_EXHAUSTED_EXT := -1000338000;
// Provided by VK_EXT_shader_object
	.VK_INCOMPATIBLE_SHADER_BINARY_EXT := 1000482000;
// Provided by VK_KHR_pipeline_binary
	.VK_PIPELINE_BINARY_MISSING_KHR := 1000483000;
// Provided by VK_KHR_pipeline_binary
	.VK_ERROR_NOT_ENOUGH_SPACE_KHR := -1000483000;
};

vk_check ::= func(result : s32) -> v0
{
	res ::= result@s64@VkResult;
	if(result != 0)
	{
		puts("vulkan call returned error code ");
		putsint(result);
		puts(" (");
		puts(__enumname(res));
		puts(")");
		putchar(10);
		__debugbreak();
	}
};

== build ==
{
	add_source_file("string.psy");
	add_link_library("Kernel32.lib");
}
