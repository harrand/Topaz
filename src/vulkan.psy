LoadLibraryA ::= func(lpLibFileName : u8&) -> u64 := extern;
FreeLibrary ::= func(hLibModule : u64) -> s32 := extern;
GetProcAddress ::= func(module : u64, lpProcName : u8&) -> u64 weak := extern;

// VkResult = s32 weak
VkApplicationInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	pApplicationName : u8&;
	applicationVersion : u32;
	pEngineName : u8&;
	engineVersion : u32;
	apiVersion : u32;
};

VkInstanceCreateInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	flags : s32 weak;
	pApplicationInfo : VkApplicationInfo&;
	enabledLayerCount : u32;
	ppEnabledLayerNames : u8&&;
	enabledExtensionCount : u32;
	ppEnabledExtensionNames : u8&&;
};

VkSystemAllocationScope ::= enum
{
	.COMMAND := 0;
	.OBJECT := 1;
	.CACHE := 2;
	.DEVICE := 3;
	.INSTANCE := 4;
};

VkInternalAllocationType ::= enum
{
	.EXECUTABLE := 0;
};

VkAllocationCallbacks ::= struct
{
	pUserData : v0&;
	pfnAllocationFunction : func(pUserData : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnReallocationFunction : func(pUserData : v0&, pOriginal : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnFreeFunction : func(pUserData : v0&, mem : v0&) -> v0;
	pfnInternalAllocation : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
	pfnInternalFree : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
};

vk_functions_t ::= struct
{
	create_instance : func(pCreateInfo : VkInstanceCreateInfo&, pAllocator : VkAllocationCallbacks&, pInstance : u64 mut&) -> s32;
	destroy_instance : func(instance : u64, pAllocator : VkAllocationCallbacks&) -> v0;
};

vk : vk_functions_t mut;

vulkan_driver : u64 weak mut := -1;
vulkan_driver_initialised : bool mut := false;

load_vk_function ::= func(funcname : u8&, module : u64) -> u64 weak
{
	addr ::= GetProcAddress(module, funcname);
	if(addr == null)
	{
		puts("failed to load function ");
		puts(funcname);
		putchar(10);
		__debugbreak();
	}
	return addr;
};

donestr ::= "done.\n";

vulkan_init ::= func() -> v0
{
	initialised_driver : bool mut := false;
	if(!vulkan_driver_initialised)
	{
		vulkan_driver = LoadLibraryA("vulkan-1.dll");
		if(vulkan_driver == 0)
		{
			__debugbreak();
		}
		puts("loading from vulkan driver...");
		vulkan_driver_initialised = true;
		initialised_driver = true;
	}
	defer puts(donestr);

	vk.create_instance = load_vk_function("vkCreateInstance", vulkan_driver);
	if(vk.create_instance == null)
	{
		__debugbreak();
	}
};

vulkan_term ::= func() -> v0
{
	// let go of the vulkan driver.
	if(vulkan_driver_initialised)
	{
		FreeLibrary(vulkan_driver);
		vulkan_driver_initialised = false;
	}
};

== build ==
{
	add_source_file("src/string.psy");
	add_link_library("Kernel32.lib");
}
