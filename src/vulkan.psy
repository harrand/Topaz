LoadLibraryA ::= func(lpLibFileName : u8&) -> u64 := extern;
FreeLibrary ::= func(hLibModule : u64) -> s32 := extern;
GetProcAddress ::= func(module : u64, lpProcName : u8&) -> u64 weak := extern;

// VkResult = s32 weak
VkApplicationInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	pApplicationName : u8&;
	applicationVersion : u32;
	pEngineName : u8&;
	engineVersion : u32;
	apiVersion : u32;
};

VkInstanceCreateInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	flags : s32 weak;
	pApplicationInfo : VkApplicationInfo&;
	enabledLayerCount : u32;
	ppEnabledLayerNames : u8&&;
	enabledExtensionCount : u32;
	ppEnabledExtensionNames : u8&&;
};

VkSystemAllocationScope ::= enum
{
	.COMMAND := 0;
	.OBJECT := 1;
	.CACHE := 2;
	.DEVICE := 3;
	.INSTANCE := 4;
};

VkInternalAllocationType ::= enum
{
	.EXECUTABLE := 0;
};

VkAllocationCallbacks ::= struct
{
	pUserData : v0&;
	pfnAllocationFunction : func(pUserData : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnReallocationFunction : func(pUserData : v0&, pOriginal : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnFreeFunction : func(pUserData : v0&, mem : v0&) -> v0;
	pfnInternalAllocation : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
	pfnInternalFree : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
};

if static(__is_windows)
{
	VkWin32SurfaceCreateInfoKHR ::= struct
	{
		sType : s32;
		pNext : v0&;
		flags : s32;
		hinstance : u64;
		hwnd : u64;
	};
}

vk_functions_t ::= struct
{
	get_instance_proc_addr : func(instance : u64, funcname : u8&) -> u64 weak;
	create_instance : func(pCreateInfo : VkInstanceCreateInfo&, pAllocator : VkAllocationCallbacks&, pInstance : u64 mut&) -> s32;
	destroy_instance : func(instance : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	if static(__is_windows)
	{
		create_win32_surface_khr : func(instance : u64, pCreateInfo : VkWin32SurfaceCreateInfoKHR&, pAllocator : VkAllocationCallbacks&, surface : u64 mut&) -> s32;
	}
};

vk : vk_functions_t mut;

vulkan_driver : u64 weak mut := -1;
vulkan_driver_initialised : bool mut := false;

load_vk_driver_fn ::= func(funcname : u8&, module : u64) -> u64 weak
{
	addr ::= GetProcAddress(module, funcname);
	if(addr == null)
	{
		puts("failed to load driver function ");
		puts(funcname);
		putchar(10);
		__debugbreak();
	}
	return addr;
};

load_vk_fn ::= func(funcname : u8&, instance : u64) -> u64 weak
{
	addr ::= vk.get_instance_proc_addr(instance, funcname);
	if(addr == null)
	{
		puts("failed to load function ");
		puts(funcname);
		putchar(10);
		__debugbreak();
	}
	return addr;
};

donestr ::= "done.\n";

vulkan_init ::= func() -> v0
{
	initialised_driver : bool mut := false;
	if(!vulkan_driver_initialised)
	{
		vulkan_driver = LoadLibraryA("vulkan-1.dll");
		if(vulkan_driver == 0)
		{
			__debugbreak();
		}
		puts("loading from vulkan driver...");
		vulkan_driver_initialised = true;
		initialised_driver = true;
	}
	defer puts(donestr);

	vk.create_instance = load_vk_driver_fn("vkCreateInstance", vulkan_driver);
	vk.destroy_instance = load_vk_driver_fn("vkDestroyInstance", vulkan_driver);
	vk.get_instance_proc_addr = load_vk_driver_fn("vkGetInstanceProcAddr", vulkan_driver);

	if static(__is_windows)
	{
		vk.create_win32_surface_khr = load_vk_driver_fn("vkCreateWin32SurfaceKHR", vulkan_driver);
	}
};

vulkan_term ::= func() -> v0
{
	// let go of the vulkan driver.
	if(vulkan_driver_initialised)
	{
		FreeLibrary(vulkan_driver);
		vulkan_driver_initialised = false;
	}
};

VK_MAKE_API_VERSION ::= func(variant : u32 weak, major : u32 weak, minor : u32 weak, patch : u32 weak) -> u32
{
	return (variant * 536870912) | (major * 4194304) | (minor * 4096) | patch;
};

VkResult ::= enum
{
	.VK_SUCCESS := 0;
	.VK_NOT_READY := 1;
	.VK_TIMEOUT := 2;
	.VK_EVENT_SET := 3;
	.VK_EVENT_RESET := 4;
	.VK_INCOMPLETE := 5;
	.VK_ERROR_OUT_OF_HOST_MEMORY := -1;
	.VK_ERROR_OUT_OF_DEVICE_MEMORY := -2;
	.VK_ERROR_INITIALIZATION_FAILED := -3;
	.VK_ERROR_DEVICE_LOST := -4;
	.VK_ERROR_MEMORY_MAP_FAILED := -5;
	.VK_ERROR_LAYER_NOT_PRESENT := -6;
	.VK_ERROR_EXTENSION_NOT_PRESENT := -7;
	.VK_ERROR_FEATURE_NOT_PRESENT := -8;
	.VK_ERROR_INCOMPATIBLE_DRIVER := -9;
	.VK_ERROR_TOO_MANY_OBJECTS := -10;
	.VK_ERROR_FORMAT_NOT_SUPPORTED := -11;
	.VK_ERROR_FRAGMENTED_POOL := -12;
	.VK_ERROR_UNKNOWN := -13;
	.VK_ERROR_OUT_OF_POOL_MEMORY := -1000069000;
// Provided by VK_VERSION_1_1
	.VK_ERROR_INVALID_EXTERNAL_HANDLE := -1000072003;
// Provided by VK_VERSION_1_2
	.VK_ERROR_FRAGMENTATION := -1000161000;
// Provided by VK_VERSION_1_2
	.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS := -1000257000;
// Provided by VK_VERSION_1_3
	.VK_PIPELINE_COMPILE_REQUIRED := 1000297000;
// Provided by VK_VERSION_1_4
	.VK_ERROR_NOT_PERMITTED := -1000174001;
// Provided by VK_KHR_surface
	.VK_ERROR_SURFACE_LOST_KHR := -1000000000;
// Provided by VK_KHR_surface
	.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR := -1000000001;
// Provided by VK_KHR_swapchain
	.VK_SUBOPTIMAL_KHR := 1000001003;
// Provided by VK_KHR_swapchain
	.VK_ERROR_OUT_OF_DATE_KHR := -1000001004;
// Provided by VK_KHR_display_swapchain
	.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR := -1000003001;
// Provided by VK_EXT_debug_report
	.VK_ERROR_VALIDATION_FAILED_EXT := -1000011001;
// Provided by VK_NV_glsl_shader
	.VK_ERROR_INVALID_SHADER_NV := -1000012000;
// Provided by VK_KHR_video_queue
	.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR := -1000023000;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR := -1000023001;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR := -1000023002;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR := -1000023003;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR := -1000023004;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR := -1000023005;
// Provided by VK_EXT_image_drm_format_modifier
	.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT := -1000158000;
// Provided by VK_EXT_full_screen_exclusive
	.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT := -1000255000;
// Provided by VK_KHR_deferred_host_operations
	.VK_THREAD_IDLE_KHR := 1000268000;
// Provided by VK_KHR_deferred_host_operations
	.VK_THREAD_DONE_KHR := 1000268001;
// Provided by VK_KHR_deferred_host_operations
	.VK_OPERATION_DEFERRED_KHR := 1000268002;
// Provided by VK_KHR_deferred_host_operations
	.VK_OPERATION_NOT_DEFERRED_KHR := 1000268003;
// Provided by VK_KHR_video_encode_queue
	.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR := -1000299000;
// Provided by VK_EXT_image_compression_control
	.VK_ERROR_COMPRESSION_EXHAUSTED_EXT := -1000338000;
// Provided by VK_EXT_shader_object
	.VK_INCOMPATIBLE_SHADER_BINARY_EXT := 1000482000;
// Provided by VK_KHR_pipeline_binary
	.VK_PIPELINE_BINARY_MISSING_KHR := 1000483000;
// Provided by VK_KHR_pipeline_binary
	.VK_ERROR_NOT_ENOUGH_SPACE_KHR := -1000483000;
};

vk_check ::= func(result : s32) -> v0
{
	res ::= result@s64@VkResult;
	if(result != 0)
	{
		puts("vulkan call returned error code ");
		putsint(result);
		puts(" (");
		puts(__enumname(res));
		puts(")");
		putchar(10);
		__debugbreak();
	}
};


== build ==
{
	add_source_file("src/string.psy");
	add_link_library("Kernel32.lib");
}
