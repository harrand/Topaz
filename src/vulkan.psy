LoadLibraryA ::= func(lpLibFileName : u8&) -> u64 := extern;
FreeLibrary ::= func(hLibModule : u64) -> s32 := extern;
GetProcAddress ::= func(module : u64, lpProcName : u8&) -> u64 weak := extern;

// VkResult = s32 weak
VkApplicationInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	pApplicationName : u8&;
	applicationVersion : u32;
	pEngineName : u8&;
	engineVersion : u32;
	apiVersion : u32;
};

VkInstanceCreateInfo ::= struct
{
	sType : s32 weak;
	pNext : v0& weak;
	flags : s32 weak;
	pApplicationInfo : VkApplicationInfo&;
	enabledLayerCount : u32;
	ppEnabledLayerNames : u8&&;
	enabledExtensionCount : u32;
	ppEnabledExtensionNames : u8&&;
};

VkSystemAllocationScope ::= enum
{
	.COMMAND := 0;
	.OBJECT := 1;
	.CACHE := 2;
	.DEVICE := 3;
	.INSTANCE := 4;
};

VkInternalAllocationType ::= enum
{
	.EXECUTABLE := 0;
};

VkAllocationCallbacks ::= struct
{
	pUserData : v0&;
	pfnAllocationFunction : func(pUserData : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnReallocationFunction : func(pUserData : v0&, pOriginal : v0&, size : u64, align : u64, allocationScope : s32) -> v0&;
	pfnFreeFunction : func(pUserData : v0&, mem : v0&) -> v0;
	pfnInternalAllocation : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
	pfnInternalFree : func(pUserData : v0&, size : u64, allocationType : s32, allocationScope : s32) -> v0;
};

VkMemoryAllocateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	allocationSize : u64;
	memoryTypeIndex : u32;
};

if static(__is_windows)
{
	VkWin32SurfaceCreateInfoKHR ::= struct
	{
		sType : s32;
		pNext : v0&;
		flags : s32;
		hinstance : u64;
		hwnd : u64;
	};
}

VkPhysicalDeviceLimits ::= struct
{
	maxImageDimension1D : u32;
	maxImageDimension2D : u32;
	maxImageDimension3D : u32;
	maxImageDimensionCube : u32;
	maxImageArrayLayers : u32;
	maxTexelBufferElements : u32;
	maxUniformBufferRange : u32;
	maxStorageBufferRange : u32;
	maxPushConstantSize : u32;
	maxMemoryAllocationCount : u32;
	maxSamplerAllocationCount : u32;
	bufferImageGranularity : u64;
	sparseAddressSpaceSize : u64;
	maxBoundDescriptorSets : u32;
	maxPerStageDescriptorSamplers : u32;
	maxPerStageDescriptorUniformSamplers : u32;
	maxPerStageDescriptorStorageSamplers : u32;
	maxPerStageDescriptorSampledImages : u32;
	maxPerStageDescriptorStorageImages : u32;
	maxPerStageDescriptorInputAttachments : u32;
	maxPerStageResources : u32;
	maxDescriptorSetSamplers : u32;
	maxDescriptorSetUniformBuffers : u32;
	maxDescriptorSetUniformBuffersDynamic : u32;
	maxDescriptorSetStorageBuffers : u32;
	maxDescriptorSetStorageBuffersDynamic : u32;
	maxDescriptorSetSampledImages : u32;
	maxDescriptorSetStorageImages : u32;
	maxDescriptorSetInputAttachments : u32;
	maxVertexInputAttributes : u32;
	maxVertexInputBindings : u32;
	maxVertexInputAttributeOffset : u32;
	maxVertexInputBindingStride : u32;
	maxVertexOutputComponents : u32;
	maxTessellationGenerationLevel : u32;
	maxTessellationPatchSize : u32;
	maxTessellationControlPerVertexInputComponents : u32;
	maxTessellationControlPerVertexOutputComponents : u32;
	maxTessellationControlPerPatchOutputComponents : u32;
	maxTessellationControlTotalOutputComponents : u32;
	maxTessellationEvaluationInputComponents : u32;
	maxTessellationEvaluationOutputComponents : u32;
	maxGeometryShaderInvocations : u32;
	maxGeometryInputComponents : u32;
	maxGeometryOutputComponents : u32;
	maxGeometryOutputVertices : u32;
	maxGeometryTotalOutputComponents : u32;
	maxFragmentInputComponents : u32;
	maxFragmentOutputAttachments : u32;
	maxFragmentDualSrcAttachments : u32;
	maxFragmentCombinedOutputResources : u32;
	maxComputeSharedMemorySize : u32;
	maxComputeWorkGroupCount : u32#3;
	maxComputeWorkGroupInvocations : u32;
	maxComputeWorkGroupSize : u32#3;
	subPixelPrecisionBits : u32;
	subTexelPrecisionBits : u32;
	mipmapPrecisionBits : u32;
	maxDrawIndexedIndexValue : u32;
	maxDrawIndirectCount : u32;
	maxSamplerLodBias : f32;
	maxSamplerAnisotropy : f32;
	maxViewports : u32;
	maxViewportDimensions : u32#2;
	viewportBoundsRange : f32#2;
	viewportSubPixelBits : u32;
	minMemoryMapAlignment : u64;
	minTexelBufferOffsetAlignment : u64;
	minUniformBufferOffsetAlignment : u64;
	minStorageBufferOffsetAlignment : u64;
	minTexelOffset : s32;
	maxTexelOffset : u32;
	minTexelGatherOffset : s32;
	maxTexelGatherOffset : u32;
	minInterpolationOffset : f32;
	maxInterpolationOffset : f32;
	subPixelInterpolationOffsetBits : u32;
	maxFramebufferWidth : u32;
	maxFramebufferHeight : u32;
	maxFramebufferLayers : u32;
	framebufferColorSampleCounts : u32;
	framebufferDepthSampleCounts : u32;
	framebufferStencilSampleCounts : u32;
	framebufferNoAttachmentsSampleCounts : u32;
	maxColorAttachments : u32;
	sampledImageColorSampleCounts : u32;
	sampledImageIntegerSampleCounts : u32;
	sampledImageDepthSampleCounts : u32;
	sampledImageStencilSampleCounts : u32;
	storageImageSampleCounts : u32;
	maxSampleMaskWords : u32;
	timestampComputeAndGraphics : u32;
	timestampPeriod : f32;
	maxClipDistances : u32;
	maxCullDistances : u32;
	maxCombinedClipAndCullDistances : u32;
	discreteQueuePriorities : u32;
	pointSizeRange : f32#2;
	lineWidthRange : f32#2;
	pointSizeGranularity : f32;
	lineWidthGranularity : f32;
	strictLines : u32;
	standardSampleLocations : u32;
	optimalBufferCopyOffsetAlignment : u64;
	optimalBufferCopyRowPitchAlignment : u64;
	nonCoherentAtomSize : u64;
};

VkPhysicalDeviceSparseProperties ::= struct
{
	residencyStandard2DBlockShape : u32;
	residencyStandard2DMultisampleBlockShape : u32;
	residencyStandard3DBlockShape : u32;
	residencyAlignedMipSize : u32;
	residencyNonResidentStrict : u32;
};

VkPhysicalDeviceProperties ::= struct
{
	apiVersion : u32;
	driverVersion : u32;
	vendorID : u32;
	deviceID : u32;
	deviceType : s32;
	deviceName : u8#256;
	pipelineCacheUUID : u8#16;
	limits : VkPhysicalDeviceLimits;
	sparseProperties : VkPhysicalDeviceSparseProperties;
};

VkMemoryType ::= struct
{
	propertyFlags : s32;
	heapIndex : u32;
};

VkMemoryHeap ::= struct
{
	size : u64;
	flags : u32;
};

VkPhysicalDeviceMemoryProperties ::= struct
{
	memoryTypeCount : u32;
	memoryTypes : VkMemoryType#32;
	memoryHeapCount : u32;
	memoryHeaps : VkMemoryHeap#32;
};

VkDeviceQueueCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	queueFamilyIndex : u32;
	queueCount : u32;
	pQueuePriorities : f32&;
};

VkPhysicalDeviceVulkan13Features ::= struct
{
	sType : s32;
	pNext : v0&;
	robustImageAccess : u32;
	inlineUniformBlock : u32;
	descriptorBindingInlineUniformBlockUpdateAfterBind : u32;
	pipelineCreationCacheControl : u32;
	privateData : u32;
	shaderDemoteToHelperInvocation : u32;
	shaderTerminateInvocation : u32;
	subgroupSizeControl : u32;
	computeFullSubgroups : u32;
	synchronization2 : u32;
	textureCompressionASTC_HDR : u32;
	shaderZeroInitializeWorkgroupMemory : u32;
	dynamicRendering : u32;
	shaderIntegerDotProduct : u32;
	maintenance4 : u32;
};

VkPhysicalDeviceVulkan12Features ::= struct
{
	sType : s32;
	pNext : v0&;
	samplerMirrorClampToEdge : u32;
	drawIndirectCount : u32;
	storageBuffer8BitAccess : u32;
	uniformAndStorageBuffer8BitAccess : u32;
	storagePushConstant8 : u32;
	shaderBufferInt64Atomics : u32;
	shaderSharedInt64Atomics : u32;
	shaderFloat16 : u32;
	shaderInt8 : u32;
	descriptorIndexing : u32;
	shaderInputAttachmentArrayDynamicIndexing : u32;
	shaderUniformTexelBufferArrayDynamicIndexing : u32;
	shaderStorageTexelBufferArrayDynamicIndexing : u32;
	shaderUniformBufferArrayNonUniformIndexing : u32;
	shaderSampledImageArrayNonUniformIndexing : u32;
	shaderStorageBufferArrayNonUniformIndexing : u32;
	shaderStorageImageArrayNonUniformIndexing : u32;
	shaderInputAttachmentArrayNonUniformIndexing : u32;
	shaderUniformTexelBufferArrayNonUniformIndexing : u32;
	shaderStorageTexelBufferArrayNonUniformIndexing : u32;
	descriptorBindingUniformBufferUpdateAfterBind : u32;
	descriptorBindingSampledImageUpdateAfterBind : u32;
	descriptorBindingStorageImageUpdateAfterBind : u32;
	descriptorBindingStorageBufferUpdateAfterBind : u32;
	descriptorBindingUniformTexelBufferUpdateAfterBind : u32;
	descriptorBindingStorageTexelBufferUpdateAfterBind : u32;
	descriptorBindingUpdateUnusedWhilePending : u32;
	descriptorBindingPartiallyBound : u32;
	descriptorBindingVariableDescriptorCount : u32;
	runtimeDescriptorArray : u32;
	samplerFilterMinmax : u32;
	scalarBlockLayout : u32;
	imagelessFramebuffer : u32;
	uniformBufferStandardLayout : u32;
	shaderSubgroupExtendedTypes : u32;
	separateDepthStencilLayouts : u32;
	hostQueryReset : u32;
	timelineSemaphore : u32;
	bufferDeviceAddress : u32;
	bufferDeviceAddressCaptureReplay : u32;
	bufferDeviceAddressMultiDevice : u32;
	vulkanMemoryModel : u32;
	vulkanMemoryModelDeviceScope : u32;
	vulkanMemoryModelAvailabilityVisibilityChains : u32;
	shaderOutputViewportIndex : u32;
	shaderOutputLayer : u32;
	subgroupBroadcastDynamicId : u32;
};

VkPhysicalDeviceFeatures ::= struct
{
	robustBufferAccess : u32;
	fullDrawIndexUint32 : u32;
	imageCubeArray : u32;
	independentBlend : u32;
	geometryShader : u32;
	tessellationShader : u32;
	sampleRateShading : u32;
	dualSrcBlend : u32;
	logicOp : u32;
	multiDrawIndirect : u32;
	drawIndirectFirstInstance : u32;
	depthClamp : u32;
	depthBiasClamp : u32;
	fillModeNonSolid : u32;
	depthBounds : u32;
	wideLines : u32;
	largePoints : u32;
	alphaToOne : u32;
	multiViewport : u32;
	samplerAnisotropy : u32;
	textureCompressionETC2 : u32;
	textureCompressionASTC_LDR : u32;
	textureCompressionBC : u32;
	occlusionQueryPrecise : u32;
	pipelineStatisticsQuery : u32;
	vertexPipelineStoresAndAtomics : u32;
	fragmentStoresAndAtomics : u32;
	shaderTessellationAndGeometryPointSize : u32;
	shaderImageGatherExtended : u32;
	shaderStorageImageExtendedFormats : u32;
	shaderStorageImageMultisample : u32;
	shaderStorageImageReadWithoutFormat : u32;
	shaderStorageImageWriteWithoutFormat : u32;
	shaderUniformBufferArrayDynamicIndexing : u32;
	shaderSampledImageArrayDynamicIndexing : u32;
	shaderStorageBufferArrayDynamicIndexing : u32;
	shaderStorageImageArrayDynamicIndexing : u32;
	shaderClipDistance : u32;
	shaderCullDistance : u32;
	shaderFloat64 : u32;
	shaderInt64 : u32;
	shaderInt16 : u32;
	shaderResourceResidency : u32;
	shaderResourceMinLod : u32;
	sparseBinding : u32;
	sparseResidencyBuffer : u32;
	sparseResidencyImage2D : u32;
	sparseResidencyImage3D : u32;
	sparseResidency2Samples : u32;
	sparseResidency4Samples : u32;
	sparseResidency8Samples : u32;
	sparseResidency16Samples : u32;
	sparseResidencyAliased : u32;
	variableMultisampleRate : u32;
	inheritedQueries : u32;
};

VkPhysicalDeviceFeatures2 ::= struct
{
	sType : s32;
	pNext : v0&;
	features : VkPhysicalDeviceFeatures;
};

VkDeviceCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	queueCreateInfoCount : u32;
	pQueueCreateInfos : VkDeviceQueueCreateInfo&;
	enabledLayerCount : u32;
	ppEnabledLayerNames : u8&&;
	enabledExtensionCount : u32;
	ppEnabledExtensionNames : u8&&;
	pEnabledFeatures : VkPhysicalDeviceFeatures&;
};

VkExtent2D ::= struct
{
	width : u32;
	height : u32;
};

VkExtent3D ::= struct
{
	width : u32;
	height : u32;
	depth : u32;
};

VkQueueFamilyProperties ::= struct
{
	queueFlags : u32;
	queueCount : u32;
	timestampValidBits : u32;
	minImageTransferGranularity : VkExtent3D;
};

VkSurfaceCapabilitiesKHR ::= struct
{
	minImageCount : u32;
	maxImageCount : u32;
	currentExtent : VkExtent2D;
	minImageExtent : VkExtent2D;
	maxImageExtent : VkExtent2D;
	maxImageArrayLayers : u32;
	supportedTransforms : s32;
	currentTransform : s32;
	supportedCompositeAlpha : s32;
	supportedUsageFlags : s32;
};

VkSwapchainCreateInfoKHR ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	surface : u64;
	minImageCount : u32;
	imageFormat : s32;
	imageColorSpace : s32;
	imageExtent : VkExtent2D;
	imageArrayLayers : u32;
	imageUsage : s32;
	imageSharingMode : s32;
	queueFamilyIndexCount : u32;
	pQueueFamilyIndices : u32&;
	preTransform : s32;
	compositeAlpha : s32;
	presentMode : s32;
	clipped : u32;
	oldSwapchain : u64;
};

VkCommandPoolCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	queueFamilyIndex : u32;
};

VkCommandBufferAllocateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	commandPool : u64;
	level : s32;
	commandBufferCount : u32;
};

VkFenceCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
};

VkSemaphoreCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
};

VkDescriptorSetLayoutBinding ::= struct
{
	binding : u32;
	descriptorType : s32;
	descriptorCount : u32;
	stageFlags : s32;
	pImmutableSamplers : u64&;
};

VkDescriptorSetLayoutBindingFlagsCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	bindingCount : u32;
	pBindingFlags : s32&;
};

VkDescriptorSetLayoutCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	bindingCount : u32;
	pBindings : VkDescriptorSetLayoutBinding&;
};

VkPushConstantRange ::= struct
{
	stageFlags : s32;
	offset : u32;
	size : u32;
};

VkPipelineLayoutCreateInfo ::= struct
{
	sType : s32;
	pNext : v0&;
	flags : s32;
	setLayoutCount : u32;
	pSetLayouts : u64&;
	pushConstantRangeCount : u32;
	pPushConstantRanges : VkPushConstantRange&;
};

vk_functions_t ::= struct
{
	get_instance_proc_addr : func(instance : u64, funcname : u8&) -> u64 weak;
	create_instance : func(pCreateInfo : VkInstanceCreateInfo&, pAllocator : VkAllocationCallbacks&, pInstance : u64 mut&) -> s32;
	destroy_instance : func(instance : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	allocate_memory : func(device : u64, pAllocateInfo : VkMemoryAllocateInfo&, pAllocator : VkAllocationCallbacks&, pMemory : u64 mut&) -> s32;
	free_memory : func(device : u64, memory : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	bind_buffer_memory : func(device : u64, buffer : u64, memory : u64, memoryOffset : u64) -> s32;
	bind_image_memory : func(device : u64, image : u64, memory : u64, memoryOffset : u64) -> s32;

	if static(__is_windows)
	{
		create_win32_surface_khr : func(instance : u64, pCreateInfo : VkWin32SurfaceCreateInfoKHR&, pAllocator : VkAllocationCallbacks&, surface : u64 mut&) -> s32;
	}
	destroy_surface_khr : func(instance : u64, surface : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	create_swapchain_khr : func(device : u64, pCreateInfo : VkSwapchainCreateInfoKHR&, pAllocator : VkAllocationCallbacks&, pSwapchain : u64 mut&) -> s32;
	destroy_swapchain_khr : func(device : u64, swapchain : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	enumerate_physical_devices : func(instance : u64, pPhysicalDeviceCount : u32 mut&, pPhysicalDevices : u64 mut&) -> s32;
	get_physical_device_properties : func(physicalDevice : u64, pProperties : VkPhysicalDeviceProperties mut&) -> v0;
	get_physical_device_memory_properties : func(physicalDevice : u64, pMemoryProperties : VkPhysicalDeviceMemoryProperties mut&) -> v0;
	get_physical_device_queue_family_properties : func(physicalDevice : u64, pQueueFamilyPropertyCount : u32 mut&, pQueueFamilyProperties : VkQueueFamilyProperties mut&) -> v0;
	get_physical_device_surface_capabilities_khr : func(physicalDevice : u64, surface : u64, pSurfaceCapabilities : VkSurfaceCapabilitiesKHR mut&) -> s32;

	create_device : func(physicalDevice : u64, pCreateInfo : VkDeviceCreateInfo&, pAllocator : VkAllocationCallbacks&, pDevice : u64 mut&) -> s32;
	destroy_device : func(device : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	get_device_queue : func(device : u64, queueFamilyIndex : u32, queueIndex : u32, pQueue : u64 mut&) -> v0;

	create_command_pool : func(device : u64, pCreateInfo : VkCommandPoolCreateInfo&, pAllocator : VkAllocationCallbacks&, pCommandPool : u64 mut&) -> s32;
	destroy_command_pool : func(device : u64, commandPool : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	allocate_command_buffers : func(device : u64, pAllocateInfo : VkCommandBufferAllocateInfo&, pCommandBuffers : u64 mut&) -> s32;

	create_fence : func(device : u64, pCreateInfo : VkFenceCreateInfo&, pAllocator : VkAllocationCallbacks&, pFence : u64 mut&) -> s32;
	destroy_fence : func(device : u64, fence : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	create_semaphore : func(device : u64, pCreateInfo : VkSemaphoreCreateInfo&, pAllocator : VkAllocationCallbacks&, pSemaphore : u64 mut&) -> s32;
	destroy_semaphore : func(device : u64, semaphore : u64, pAllocator : VkAllocationCallbacks&) -> v0;

	create_descriptor_set_layout : func(device : u64, pCreateInfo : VkDescriptorSetLayoutCreateInfo&, pAllocator : VkAllocationCallbacks&, pSetLayout : u64 mut&) -> s32;
	destroy_descriptor_set_layout : func(device : u64, descriptorSetLayout : u64, pAllocator : VkAllocationCallbacks&) -> v0;
	create_pipeline_layout : func(device : u64, pCreateInfo : VkPipelineLayoutCreateInfo&, pAllocator : VkAllocationCallbacks&, pPipelineLayout : u64 mut&) -> s32;
	destroy_pipeline_layout : func(device : u64, pipelineLayout : u64, pAllocator : VkAllocationCallbacks&) -> v0;
};

vk : vk_functions_t mut;

vulkan_driver : u64 weak mut := -1;
vulkan_driver_initialised : bool mut := false;

load_vk_driver_fn ::= func(funcname : u8&, module : u64) -> u64 weak
{
	addr ::= GetProcAddress(module, funcname);
	if(addr == null)
	{
		puts("failed to load driver function ");
		puts(funcname);
		putchar(10);
		__debugbreak();
	}
	return addr;
};

load_vk_fn ::= func(funcname : u8&, instance : u64) -> u64 weak
{
	addr ::= vk.get_instance_proc_addr(instance, funcname);
	if(addr == null)
	{
		puts("failed to load function ");
		puts(funcname);
		putchar(10);
		__debugbreak();
	}
	return addr;
};

donestr ::= "done.\n";

vulkan_init ::= func() -> v0
{
	initialised_driver : bool mut := false;
	if(!vulkan_driver_initialised)
	{
		vulkan_driver = LoadLibraryA("vulkan-1.dll");
		if(vulkan_driver == 0)
		{
			__debugbreak();
		}
		puts("loading from vulkan driver...");
		vulkan_driver_initialised = true;
		initialised_driver = true;
	}
	defer puts(donestr);

	vk.create_instance = load_vk_driver_fn("vkCreateInstance", vulkan_driver);
	vk.destroy_instance = load_vk_driver_fn("vkDestroyInstance", vulkan_driver);
	vk.get_instance_proc_addr = load_vk_driver_fn("vkGetInstanceProcAddr", vulkan_driver);
};

vulkan_load_functions ::= func(instance : u64) -> v0
{
	vk.allocate_memory = load_vk_fn("vkAllocateMemory", instance);
	vk.free_memory = load_vk_fn("vkFreeMemory", instance);

	vk.bind_buffer_memory = load_vk_fn("vkBindBufferMemory", instance);
	vk.bind_image_memory = load_vk_fn("vkBindImageMemory", instance);

	if static(__is_windows)
	{
		vk.create_win32_surface_khr = load_vk_fn("vkCreateWin32SurfaceKHR", instance);
	}
	vk.destroy_surface_khr = load_vk_fn("vkDestroySurfaceKHR", instance);
	vk.create_swapchain_khr = load_vk_fn("vkCreateSwapchainKHR", instance);
	vk.destroy_swapchain_khr = load_vk_fn("vkDestroySwapchainKHR", instance);

	vk.enumerate_physical_devices = load_vk_fn("vkEnumeratePhysicalDevices", instance);
	vk.get_physical_device_properties = load_vk_fn("vkGetPhysicalDeviceProperties", instance);
	vk.get_physical_device_memory_properties = load_vk_fn("vkGetPhysicalDeviceMemoryProperties", instance);
	vk.get_physical_device_queue_family_properties = load_vk_fn("vkGetPhysicalDeviceQueueFamilyProperties", instance);
	vk.get_physical_device_surface_capabilities_khr = load_vk_fn("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", instance);

	vk.create_device = load_vk_fn("vkCreateDevice", instance);
	vk.destroy_device = load_vk_fn("vkDestroyDevice", instance);
	vk.get_device_queue = load_vk_fn("vkGetDeviceQueue", instance);

	vk.create_command_pool = load_vk_fn("vkCreateCommandPool", instance);
	vk.destroy_command_pool = load_vk_fn("vkDestroyCommandPool", instance);
	vk.allocate_command_buffers = load_vk_fn("vkAllocateCommandBuffers", instance);

	vk.create_fence = load_vk_fn("vkCreateFence", instance);
	vk.destroy_fence = load_vk_fn("vkDestroyFence", instance);

	vk.create_semaphore = load_vk_fn("vkCreateSemaphore", instance);
	vk.destroy_semaphore = load_vk_fn("vkDestroySemaphore", instance);

	vk.create_descriptor_set_layout = load_vk_fn("vkCreateDescriptorSetLayout", instance);
	vk.destroy_descriptor_set_layout = load_vk_fn("vkDestroyDescriptorSetLayout", instance);
	vk.create_pipeline_layout = load_vk_fn("vkCreatePipelineLayout", instance);
	vk.destroy_pipeline_layout = load_vk_fn("vkDestroyPipelineLayout", instance);
};

vulkan_term ::= func() -> v0
{
	// let go of the vulkan driver.
	if(vulkan_driver_initialised)
	{
		FreeLibrary(vulkan_driver);
		vulkan_driver_initialised = false;
	}
};

VK_MAKE_API_VERSION ::= func(variant : u32 weak, major : u32 weak, minor : u32 weak, patch : u32 weak) -> u32
{
	return (variant * 536870912) | (major * 4194304) | (minor * 4096) | patch;
};

VkResult ::= enum
{
	.VK_SUCCESS := 0;
	.VK_NOT_READY := 1;
	.VK_TIMEOUT := 2;
	.VK_EVENT_SET := 3;
	.VK_EVENT_RESET := 4;
	.VK_INCOMPLETE := 5;
	.VK_ERROR_OUT_OF_HOST_MEMORY := -1;
	.VK_ERROR_OUT_OF_DEVICE_MEMORY := -2;
	.VK_ERROR_INITIALIZATION_FAILED := -3;
	.VK_ERROR_DEVICE_LOST := -4;
	.VK_ERROR_MEMORY_MAP_FAILED := -5;
	.VK_ERROR_LAYER_NOT_PRESENT := -6;
	.VK_ERROR_EXTENSION_NOT_PRESENT := -7;
	.VK_ERROR_FEATURE_NOT_PRESENT := -8;
	.VK_ERROR_INCOMPATIBLE_DRIVER := -9;
	.VK_ERROR_TOO_MANY_OBJECTS := -10;
	.VK_ERROR_FORMAT_NOT_SUPPORTED := -11;
	.VK_ERROR_FRAGMENTED_POOL := -12;
	.VK_ERROR_UNKNOWN := -13;
	.VK_ERROR_OUT_OF_POOL_MEMORY := -1000069000;
// Provided by VK_VERSION_1_1
	.VK_ERROR_INVALID_EXTERNAL_HANDLE := -1000072003;
// Provided by VK_VERSION_1_2
	.VK_ERROR_FRAGMENTATION := -1000161000;
// Provided by VK_VERSION_1_2
	.VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS := -1000257000;
// Provided by VK_VERSION_1_3
	.VK_PIPELINE_COMPILE_REQUIRED := 1000297000;
// Provided by VK_VERSION_1_4
	.VK_ERROR_NOT_PERMITTED := -1000174001;
// Provided by VK_KHR_surface
	.VK_ERROR_SURFACE_LOST_KHR := -1000000000;
// Provided by VK_KHR_surface
	.VK_ERROR_NATIVE_WINDOW_IN_USE_KHR := -1000000001;
// Provided by VK_KHR_swapchain
	.VK_SUBOPTIMAL_KHR := 1000001003;
// Provided by VK_KHR_swapchain
	.VK_ERROR_OUT_OF_DATE_KHR := -1000001004;
// Provided by VK_KHR_display_swapchain
	.VK_ERROR_INCOMPATIBLE_DISPLAY_KHR := -1000003001;
// Provided by VK_EXT_debug_report
	.VK_ERROR_VALIDATION_FAILED_EXT := -1000011001;
// Provided by VK_NV_glsl_shader
	.VK_ERROR_INVALID_SHADER_NV := -1000012000;
// Provided by VK_KHR_video_queue
	.VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR := -1000023000;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR := -1000023001;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR := -1000023002;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR := -1000023003;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR := -1000023004;
// Provided by VK_KHR_video_queue
	.VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR := -1000023005;
// Provided by VK_EXT_image_drm_format_modifier
	.VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT := -1000158000;
// Provided by VK_EXT_full_screen_exclusive
	.VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT := -1000255000;
// Provided by VK_KHR_deferred_host_operations
	.VK_THREAD_IDLE_KHR := 1000268000;
// Provided by VK_KHR_deferred_host_operations
	.VK_THREAD_DONE_KHR := 1000268001;
// Provided by VK_KHR_deferred_host_operations
	.VK_OPERATION_DEFERRED_KHR := 1000268002;
// Provided by VK_KHR_deferred_host_operations
	.VK_OPERATION_NOT_DEFERRED_KHR := 1000268003;
// Provided by VK_KHR_video_encode_queue
	.VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR := -1000299000;
// Provided by VK_EXT_image_compression_control
	.VK_ERROR_COMPRESSION_EXHAUSTED_EXT := -1000338000;
// Provided by VK_EXT_shader_object
	.VK_INCOMPATIBLE_SHADER_BINARY_EXT := 1000482000;
// Provided by VK_KHR_pipeline_binary
	.VK_PIPELINE_BINARY_MISSING_KHR := 1000483000;
// Provided by VK_KHR_pipeline_binary
	.VK_ERROR_NOT_ENOUGH_SPACE_KHR := -1000483000;
};

vk_check ::= func(result : s32) -> v0
{
	res ::= result@s64@VkResult;
	if(result != 0)
	{
		puts("vulkan call returned error code ");
		putsint(result);
		puts(" (");
		puts(__enumname(res));
		puts(")");
		putchar(10);
		__debugbreak();
	}
};


== build ==
{
	add_source_file("src/string.psy");
	add_link_library("Kernel32.lib");
}
