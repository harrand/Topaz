tz_job ::= enum
{
	.invalid := -1;
};

[[private]]
impl_worker_data ::= struct
{
	global_thread_id : u64;
	local_thread_id : u64;
	close_flag : bool;

	local_arena : arena mut& mut;
};

[[private]]
workers : impl_worker_data mut& mut;
[[private]]
worker_count : u32 mut;

[[private]]
job_wrapper ::= struct
{
	fn : func() -> v0;
	running : bool;
	finished : bool;
};

[[private]]
job_global_arena : arena mut& mut;
[[private]]
job_queue : tz_job mut& mut;
[[private]]
job_queue_size : u64 mut;
[[private]]
job_queue_cap : u64 mut;

// stores all jobs.
job_storage : job_wrapper mut& mut;
job_storage_size : u64 mut;
job_storage_cap : u64 mut;

// stores a free list of indices into job_storage.
// all indices stored in the free list can be re-used.
job_free_list : tz_job mut& mut;
job_free_list_size : u64 mut;
job_free_list_cap : u64 mut;

[[private]]
impl_sleep ::= func(millis : u64) -> v0
{
	if static(__is_windows)
	{
		Sleep ::= func(dwMilliseconds : u32) -> v0 := extern;
		Sleep(millis@_);
	}
};

if static(__is_windows)
{
	GetActiveProcessorCount ::= func(groupNumber : u16) -> u32 := extern;
	CreateThread ::= func(lpThreadAttributes : v0&, dwStackSize : u64, lpStartAddress : v0& weak, lpParameter : v0& weak, dwCreationFlags : u32, lpThreadId : u32 mut&) -> u64 := extern;
	WaitForSingleObject ::= func(handle : u64, dwMillis : u32) -> u32 := extern;

	CreateMutexA ::= func(lpMutexAttributes : v0&, bInitialOwner : s32, lpName : u8&) -> u64 := extern;

	CRITICAL_SECTION ::= struct
	{
		LockCount : u32;
		RecursionCount : u32;
		OwningThread : v0&;
		LockSemaphore : v0&;
		SpinCount : u32;
	};

	InitializeCriticalSection ::= func(lpCriticalSection : CRITICAL_SECTION mut&) -> v0 := extern;
	EnterCriticalSection ::= func(lpCriticalSection : CRITICAL_SECTION mut&) -> v0 := extern;
	LeaveCriticalSection ::= func(lpCriticalSection : CRITICAL_SECTION mut&) -> v0 := extern;

	TlsAlloc ::= func() -> u32 := extern;
	TlsSetValue ::= func(dwTlsIndex : u32, lpTlsValue : v0& weak) -> s32 := extern;
	TlsGetValue ::= func(dwTlsIndex : u32) -> v0& weak := extern;

	[[private]]
	job_queue_cs : CRITICAL_SECTION mut;
	[[private]]
	job_system_tls_slot : u32 mut;
}


[[private]]
worker_tmain ::= func(p : v0&) -> u32
{
	local_arena_value : arena mut := arena_create(4096 * 1024);
	if(TlsSetValue(job_system_tls_slot, ref local_arena_value) == 0)
	{
		puts("failed to set local arena TLS");
		__debugbreak();
	}

	defer arena_destroy(local_arena_value);

	me ::= p@impl_worker_data mut&;
	me->local_arena = (ref local_arena_value);
	found_job_id : tz_job mut := tz_job.invalid;
	found_job : job_wrapper mut;
	while(!(me->close_flag))
	{
		found_job = zero;
		found_job_id = (tz_job.invalid);
		EnterCriticalSection(ref job_queue_cs);
		if(job_queue_size > 0)
		{
			found_job_id = deref(job_queue at 0);
			if(job_queue_size > 1)
			{
				__memcpy(job_queue at 0, job_queue at 1, __sizeof(deref job_queue) * (job_queue_size - 1));
			}
			job_queue_size = job_queue_size - 1;
			puts("job queue is now ");
			putuint(job_queue_size);
			putchar(10);
		}
		LeaveCriticalSection(ref job_queue_cs);

		// do the job.
		if(found_job_id != (tz_job.invalid))
		{
			EnterCriticalSection(ref job_queue_cs);
			found_job = deref(job_storage at (found_job_id@s64));
			LeaveCriticalSection(ref job_queue_cs);
			found_job.running = true;
			found_job.finished = false;
			found_job.fn();
			found_job.finished = true;

			if((found_job_id@s64) >= (job_storage_size@_))
			{
				puts("dodgy job id");
				__debugbreak();
			}
			EnterCriticalSection(ref job_queue_cs);
			deref(job_storage at (found_job_id@s64)) = found_job;
			if(job_free_list_size >= job_free_list_cap)
			{
				old_cap ::= job_free_list_cap;
				old_free_list ::= job_free_list;

				job_free_list_cap = job_free_list_cap * 2;
				job_free_list = arena_push(job_global_arena, job_free_list_cap * __sizeof(deref job_free_list));
			}
			deref(job_free_list at job_free_list_size) = found_job_id;
			job_free_list_size = job_free_list_size + 1;
			LeaveCriticalSection(ref job_queue_cs);
		}
		// otherwise sleep.
		if(found_job_id == (tz_job.invalid))
		{
			impl_sleep(1);
		}
	}
	return 0;
};

[[private]]
impl_logical_threads_count ::= func() -> u32
{
	if static(__is_windows)
	{
		return GetActiveProcessorCount(-1);
	}
};

tz_job_local_arena ::= func() -> arena mut&
{
	return TlsGetValue(job_system_tls_slot);
};

tz_job_sleep ::= func(millis : u64) -> v0
{
	impl_sleep(millis);
};

tz_job_initialise ::= func(a : arena mut&) -> v0
{
	if static(__is_windows)
	{
		timeBeginPeriod ::= func(uPeriod : u32) -> s32 := extern;
		timeBeginPeriod(1);
	}

	job_global_arena = a;

	job_storage = arena_push(a, __sizeof(deref job_storage) * 4096);
	job_storage_cap = 4096;
	job_storage_size = 0;

	job_free_list = arena_push(a, __sizeof(deref job_free_list) * 4096);
	job_free_list_cap = 4096;
	job_free_list_size = 0;

	worker_count = impl_logical_threads_count();
	workers = arena_push(a, __sizeof(impl_worker_data) * worker_count);

	InitializeCriticalSection(ref job_queue_cs);

	job_queue = arena_push(a, __sizeof(deref job_queue) * 1024);
	job_queue_size = 0;
	job_queue_cap = 1024;
	
	// note: no CRT, so no TLS by default. we have to set it up manually.
	job_system_tls_slot = TlsAlloc();

	counter : u32 mut := 0;
	wptr : impl_worker_data mut& mut;
	for(counter = 0, counter < worker_count, counter = counter + 1)
	{
		wptr = (workers at counter);
		deref(wptr) = impl_worker_data
		{
			.local_thread_id := counter@_;
			.close_flag := false;
			.local_arena := null;
		};
		(wptr->global_thread_id) = CreateThread(null, 0, worker_tmain, wptr, 0, null);
	}
};

tz_job_terminate ::= func() -> v0
{
	counter : u32 mut;
	wptr : impl_worker_data mut& mut;
	for(counter = 0, counter < worker_count, counter = counter + 1)
	{
		wptr = (workers at counter);
		(wptr->close_flag) = true;
	}
};

tz_job_worker_count ::= func() -> u32
{
	return worker_count;
};

tz_job_execute ::= func(fn : v0& weak, a : arena mut&) -> tz_job
{
	if(workers == null)
	{
		puts("tz_job_execute error: threadpool not initialised");
		__debugbreak();
	}

	EnterCriticalSection(ref job_queue_cs);
	// lets get our job id.
	ret : tz_job mut := tz_job.invalid;
	if(job_free_list_size == 0)
	{
		// need a new job.
		if(job_storage_size >= job_storage_cap)
		{
			old_cap ::= job_storage_cap;
			old_job_storage ::= job_storage;

			job_storage_cap = job_storage_cap * 2;
			job_storage = arena_push(a, job_storage_cap * __sizeof(deref job_storage));

			__memcpy(job_storage, old_job_storage, old_cap * __sizeof(deref job_storage));
		}
		ret = (job_storage_size@tz_job);
		job_storage_size = job_storage_size + 1;
	}
	if(job_free_list_size > 0)
	{
		ret = deref(job_free_list at (job_free_list_size - 1));
		job_free_list_size = job_free_list_size - 1;

		if static(__config() == "debug")
		{
			// on debug, check if free list doesn't contain duplicates.
			counter : u64 mut;
			for(counter = 0, counter < job_free_list_size, counter = counter + 1)
			{
				if(deref(job_free_list at counter) == ret)
				{
					puts("job ");
					putsint(ret@s64);
					puts(" was found as a duplicate within the free list.");
					__debugbreak();
				}
			}
		}
	}

	if(job_queue_size >= job_queue_cap)
	{
		newjobs ::= arena_push(a, __sizeof(deref job_queue) * job_queue_cap * 2);
		__memcpy(newjobs, job_queue, job_queue_cap * __sizeof(deref job_queue));
		job_queue = newjobs;
		job_queue_cap = (job_queue_cap * 2);
	}
	if((ret@s64@u64) > job_storage_size)
	{
		__debugbreak();
	}
	deref(job_storage at (ret@s64)) = job_wrapper
	{
		.fn := fn;
		.running := false;
		.finished := false;
	};
	deref(job_queue at job_queue_size) = ret;
	job_queue_size = job_queue_size + 1;
	LeaveCriticalSection(ref job_queue_cs);

	return ret;
};

tz_job_complete ::= func(job : tz_job) -> bool
{
	jobwrapper ::= deref(job_storage at (job@s64));
	return jobwrapper.finished;
};

tz_job_block ::= func(job : tz_job) -> v0
{
	while(!tz_job_complete(job))
	{
		tz_job_sleep(1);
	}
};

== build ==
{
	add_link_library("Kernel32.lib");
	add_link_library("winmm.lib");
	add_source_file("arena.psy");
}
