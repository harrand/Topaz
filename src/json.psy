json_type ::= enum
{
	.unknown := 0b00000001;
	.string := 0b00000001;
	.number := 0b00000010;
	.object := 0b00000100;
	.array := 0b00001000;
	.boolean := 0b00010000;
	.nullval := 0b00100000;
};

json_node ::= struct
{
	type : json_type;
	strval : string;
	numval : f64;
	boolval : bool;
	children_count : u64;
	children : v0&&;
};

[[private]]
impl_is_whitespace ::= func(ch : u8) -> bool
{
	if(ch == ' ')
	{
		return true;
	}
	cr ::= '\r';
	if(ch == cr)
	{
		return true;
	}
	lf ::= '\n';
	if(ch == lf)
	{
		return true;
	}
	return false;
};

[[private]]
impl_nextchar ::= macro(jd : string&, curs : u64 mut&) -> u8
{
	yield deref(string_at(jd, deref curs));
	deref(curs) = (deref(curs) + 1);
};

[[private]]
impl_skip_whitespace ::= func(json_data : string&, cursor : u64 mut&) -> v0
{
	while(impl_is_whitespace(deref(string_at(json_data, deref cursor))))
	{
		deref(cursor) = ((deref cursor) + 1);
	}
};

json_parse_object ::= func(json_data : string, cursor : u64 mut, a : arena mut&) -> json_node
{
	// skip initial {
	cursor = cursor + 1;

	return zero;
};

json_parse_value ::= func(json_data : string, cursor : u64 mut, a : arena mut&) -> json_node
{
	// skip whitespace.
	impl_skip_whitespace(ref json_data, ref cursor);
	char ::= impl_nextchar(ref json_data, ref cursor);
	if(char == '{')
	{
		return json_parse_object(json_data, cursor, a);
	}

	puts("failed to parse json. at: \"");
	puts(string_at(ref json_data, cursor));
	putchar(10);
	__unreachable();
};

json_parse ::= func(json_data : string, a : arena mut&) -> json_node
{
	cursor : u64 mut := 0;
	return json_parse_value(json_data, cursor, a);
};

== build ==
{
	add_source_file("arena.psy");
	add_source_file("string.psy");
}
