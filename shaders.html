<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Topaz: Shaders</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="tz.png"/></td>
  <td id="projectalign">
   <div id="projectname">Topaz<span id="projectnumber">&#160;4.0.0.0</span>
   </div>
   <div id="projectbrief">C++20 Graphics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Topaz&#160;Home</span></a></li>
      <li><a href="usergroup0.html"><span>API</span></a></li>
      <li><a href="shaders.html"><span>Shaders</span></a></li>
      <li><a href="graphics.html"><span>Graphics</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('shaders.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Shaders</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="tzslpage"></a>
Topaz Shader Language</h1>
<h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>TZSL is a high-level shader language with a syntax very similar to that of GLSL. A tool named tzslc ships with the engine, which can be used to build tzsl shaders to output SPIRV, GLSL shaders or SPIRV encoded within a C++ header.</p>
<p>TZSL Shaders come in five types:</p><ul>
<li>Vertex Shaders, which specify the locations of individual vertices.<ul>
<li>There are no vertex buffers, so vertex-pulling is a must.</li>
<li>Vertex shaders must exist, unless a compute shader exists.</li>
<li>If a vertex shader exists, a fragment shader must also exist.</li>
</ul>
</li>
<li>Tessellation Control Shaders, which specify how much tessellation is applied to triangles.<ul>
<li>These are optional. However, if it does exist, a tessellation evaluation shader must also exist.</li>
</ul>
</li>
<li>Tessellation Evaluation Shaders, which computes interpolated positions for tessellated triangles.<ul>
<li>These are optional. However, if it does exist, a tessellation control shader must also exist.</li>
</ul>
</li>
<li>Fragment Shaders, which processes fragments into a set of colours and optionally depth value.<ul>
<li>Fragment shaders must exist, unless a compute shader exists.</li>
<li>If a fragment shader exists, a vertex shader must also exist.</li>
</ul>
</li>
<li>Compute Shaders, which can be used to perform general-purpose computation on the GPU.<ul>
<li>If there is no vertex or fragment shader, there must be a compute shader.</li>
<li>If a compute shader exists, there must be no other shaders in the shader program.</li>
</ul>
</li>
</ul>
<p>TZSL Shaders have first-class support in the engine's build system. When specifying your application in CMake, you can specify tzsl shader files. When the application needs to be built, the shaders are compiled into specially-encoded C++ headers which you can include in your application at compile-time. This is known as a TZSL Header Import.</p>
<h1><a class="anchor" id="Language"></a>
Language</h1>
<h2><a class="anchor" id="Inputs"></a>
Inputs</h2>
<p>Fragment shaders may have inputs. These are variable passed from the output of a vertex shader. Because Topaz does not deal with input state (there are no vertex buffers), vertex shaders cannot have inputs. Compute shaders cannot have inputs either, but that is normal. Every input must have an index, type and name.</p>
<p>Syntax: <code>input(id = x) variable_type variable_name;</code> Example: <code>input(id = 0) vec2 texcoord;</code> </p>
<h2><a class="anchor" id="Outputs"></a>
Outputs</h2>
<p>Vertex and fragment shaders may have any number of outputs. These are similar to <code>out</code> variables from GLSL, although the syntax is slightly different. Every output must have an index, type and name.</p>
<p>Syntax: <code>output(id = x) variable_type variable_name;</code> Example: <code>output(id = 0) vec3 frag_colour;</code> </p>
<h2><a class="anchor" id="Resources"></a>
Resources</h2>
<p>When writing a shader, you will know about the shader resources it has access to. You might be used to the following syntaxes in OpenGL: </p><div class="fragment"><div class="line">uniform sampler2D my_image;</div>
<div class="line">layout(binding = 0) uniform MyUniformBuffer</div>
<div class="line">{</div>
<div class="line"> ...</div>
<div class="line">} buf;</div>
</div><!-- fragment --><p> Note that the syntax for specifying image and buffer resources are quite different. Because image and buffer resources are first-class objects as far as Topaz renderers are concerned, the syntax is unified and obvious: </p><div class="fragment"><div class="line">resource(<span class="keywordtype">id</span> = 0) const texture my_image;</div>
<div class="line">resource(<span class="keywordtype">id</span> = 0) const buffer MyUniformBuffer</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">} buf;</div>
</div><!-- fragment --><p> Note that specifying resource ids for shader resources is mandatory, regardless of resource type. The resource id is constant and corresponds to the tz::gl::resource_handle when being specified to a renderer. This means that resources have unique identifiers. That is, if a vertex shader specifies an image resource at id 0, and again in a fragment shader (within the same shader program), they both refer to the same resource.</p>
<p>Note: The example above is actually ill-formed &ndash; An image and buffer resource are specified, but they share the same id which is impossible; a resource is either a buffer or an image resource, never both. </p>
<h2><a class="anchor" id="preproc"></a>
Preprocessor Definitions</h2>
<p>A number of preprocessor definitions are guaranteed to be exist for all TZSL shaders. These are always defined, but their value depends on the build parameters of the target program.</p>
<p>Below are the defines whose value depends on the render-api: </p><table class="doxtable">
<tr>
<th>Define </th><th>Value (OpenGL) </th><th>Value (Vulkan)  </th></tr>
<tr>
<td>TZ_VULKAN </td><td style="text-align: center;">0 </td><td style="text-align: center;">1  </td></tr>
<tr>
<td>TZ_OGL </td><td style="text-align: center;">1 </td><td style="text-align: center;">0  </td></tr>
</table>
<p>Below are the defines whose value depends on the build-config: </p><table class="doxtable">
<tr>
<th>Define </th><th>Value (Debug) </th><th>Value (Release) </th><th>Value (Profile)  </th></tr>
<tr>
<td>TZ_DEBUG </td><td style="text-align: center;">1 </td><td style="text-align: center;">0 </td><td style="text-align: center;">0  </td></tr>
</table>
<p>Just for clarity, these are preprocessor definitions as in GLSL or C. These are useful if you want your shader to act differently on certain build configurations, but without having to write different shaders.</p>
<h3><a class="anchor" id="ex0"></a>
Example Fragment Shader</h3>
<div class="fragment"><div class="line">shader(type = fragment);</div>
<div class="line">output(<span class="keywordtype">id</span> = 0) vec4 frag_colour;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Output is a solid colour. Red if we&#39;re on Vulkan, otherwise white.</span></div>
<div class="line"><span class="preprocessor"> #if TZ_VULKAN</span></div>
<div class="line">    frag_colour = vec4(1.0, 0.0, 0.0, 1.0);</div>
<div class="line"><span class="preprocessor"> #else</span></div>
<div class="line">    frag_colour = vec4(1.0, 1.0, 1.0, 1.0);</div>
<div class="line"><span class="preprocessor"> #endif</span></div>
<div class="line">}</div>
</div><!-- fragment --> <h1><a class="anchor" id="TZSL"></a>
Library API</h1>
<p>TZSL ships with a small library providing the essentials. It is a fully documented module: <a class="el" href="group__tzsl.html">TZSL API Reference</a> </p>
<h1><a class="anchor" id="stypes"></a>
IO Blocks</h1>
<p>Below are the input and output blocks for each programmable shader type. Each shader stage has a fixed-set of input and output variables, in the <code>in::</code> and <code>out::</code> namespaces respectively. These are not the same as input and output language specifiers. </p><details >
<summary >
Vertex Shader</summary>
<table class="doxtable">
<tr>
<th>Variable </th><th>GLSL Equivalent  </th></tr>
<tr>
<td>in::vertex_id </td><td>gl_VertexID  </td></tr>
<tr>
<td>in::instance_id </td><td>gl_InstanceID  </td></tr>
<tr>
<td>in::draw_id </td><td>gl_DrawID  </td></tr>
<tr>
<td>out::position </td><td>gl_Position  </td></tr>
</table>
</details>
<details >
<summary >
Tessellation Control Shader</summary>
<table class="doxtable">
<tr>
<th>Variable </th><th>GLSL Equivalent  </th></tr>
<tr>
<td>in::input_length </td><td>gl_PatchVerticesIn  </td></tr>
<tr>
<td>in::primitive_id </td><td>gl_PrimitiveID  </td></tr>
<tr>
<td>in::invocation_id </td><td>gl_InvocationID  </td></tr>
<tr>
<td>out::inner_tessellate </td><td>gl_TessLevelInner  </td></tr>
<tr>
<td>out::outer_tessellate </td><td>gl_TessLevelOuter  </td></tr>
</table>
</details>
<details >
<summary >
Tessellation Evaluation Shader</summary>
<table class="doxtable">
<tr>
<th>Variable </th><th>GLSL Equivalent  </th></tr>
<tr>
<td>in::tess_coord </td><td>gl_TessCoord  </td></tr>
<tr>
<td>in::patch_size </td><td>gl_PatchVerticesIn  </td></tr>
<tr>
<td>in::primitive_id </td><td>gl_PrimitiveID  </td></tr>
<tr>
<td>out::position </td><td>gl_Position  </td></tr>
</table>
</details>
<details >
<summary >
Fragment Shader</summary>
<table class="doxtable">
<tr>
<th>Variable </th><th>GLSL Equivalent  </th></tr>
<tr>
<td>in::fragment_coord </td><td>gl_FragCoord  </td></tr>
<tr>
<td>out::fragment_depth </td><td>gl_FragDepth  </td></tr>
</table>
</details>
<details >
<summary >
Compute Shader</summary>
<table class="doxtable">
<tr>
<th>Variable </th><th>GLSL Equivalent  </th></tr>
<tr>
<td>in::workgroup_count </td><td>gl_NumWorkGroups  </td></tr>
<tr>
<td>in::workgroup_id </td><td>gl_WorkGroupID  </td></tr>
<tr>
<td>in::local_id </td><td>gl_LocalInvocationID  </td></tr>
<tr>
<td>in::global_id </td><td>gl_GlobalInvocationID  </td></tr>
</table>
</details>
<h1><a class="anchor" id="header_imports"></a>
TZSL Header Imports</h1>
<p>Note that this feature is optional. If you don't like it, you can completely ignore it.</p>
<p>Say you have a project structure similar to the file tree below:</p>
<table class="doxtable">
<tr>
<th>Projects/MyGame  </th></tr>
<tr>
<td>CMakeLists.txt  </td></tr>
<tr>
<td>main.cpp  </td></tr>
<tr>
<td>my_shader.vertex.tzsl  </td></tr>
<tr>
<td>my_shader.fragment.tzsl  </td></tr>
</table>
<p>Using a header import, you can access the shaders at compile-time within main.cpp. </p>
<h3><a class="anchor" id="cml_example"></a>
CMakeLists.txt</h3>
<div class="fragment"><div class="line">add_app(</div>
<div class="line">    TARGET MyGame</div>
<div class="line">    SOURCE_FILES main.cpp</div>
<div class="line">    SHADER_SOURCES</div>
<div class="line">        my_shader.vertex.tzsl</div>
<div class="line">        my_shader.fragment.tzsl</div>
<div class="line">)</div>
</div><!-- fragment --><h3><a class="anchor" id="maincpp"></a>
main.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;tz/gl/imported_shaders.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string_view&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Includes the compiled tzsl c++ header within this translation unit.</span></div>
<div class="line"><span class="comment">// NOTE: This is only doable if you specified the shader files within `add_application` in the build system.</span></div>
<div class="line"><span class="preprocessor">#include ImportedShaderHeader(my_shader, vertex)</span></div>
<div class="line"><span class="preprocessor">#include ImportedShaderHeader(my_shader, fragment)</span></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">constexpr</span> std::string_view vtx_src = ImportedShaderSource(my_shader, vertex);</div>
<div class="line">    <span class="keyword">constexpr</span> std::string_view frg_src = ImportedShaderSource(my_shader, fragment);</div>
<div class="line"> <span class="comment">// Note: The contents of the string depend on the current render-api. However, this is guaranteed to be compatible with tz::gl::ShaderInfo::set_shader(...).</span></div>
<div class="line"> <span class="comment">// For the curious: In Vulkan, the string contains SPIRV. In OpenGL, the string contains GLSL source.</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="rwe"></a>
Example Shader: tz_dynamic_triangle_demo.fragment.tzsl</h1>
<p>The following is the fragment shader used by <code>tz_dynamic_triangle_demo</code>: </p><div class="fragment"><div class="line">shader(type = fragment);</div>
<div class="line"> </div>
<div class="line">resource(<span class="keywordtype">id</span> = 1) const texture tex_sampler[1];</div>
<div class="line">input(<span class="keywordtype">id</span> = 0) vec2 texcoord;</div>
<div class="line">output(<span class="keywordtype">id</span> = 0) vec4 output_colour;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    output_colour = texture(tex_sampler[0], texcoord);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="rwe_analysis"></a>
Analysis</h2>
<ul>
<li>The shader contains a type declaration at the top, like all shaders. This informs tzslc that this is a fragment shader.</li>
<li>The shader uses a single resource, an array of samplers with index 1.</li>
<li>The shader has one input and one output, both with index 0.<ul>
<li>As you might expect, output 0 goes to the colour attachment 0, and input 0 is the first output from the vertex shader. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
